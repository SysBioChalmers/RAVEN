<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of predictLocalization</title>
  <meta name="keywords" content="predictLocalization">
  <meta name="description" content="predictLocalization">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">core</a> &gt; predictLocalization.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for core&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>predictLocalization
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>predictLocalization</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [outModel, geneLocalization, transportStruct, scores, removedRxns]=predictLocalization(model,GSS,defaultCompartment,transportCost,maxTime,plotResults) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> predictLocalization
   Tries to assign reactions to compartments in a manner that is in
   agreement with localization predictors while at the same time
   maintaining connectivity.

   model                 a model structure. If the model contains several
                         compartments they will be merged
   GSS                   gene scoring structure as from parseScores
   defaultCompartment    transport reactions are expressed as diffusion
                         between the defaultCompartment and the others.
                         This is usually the cytosol. The default
                         compartment must have a match in
                         GSS
   transportCost         the cost for including a transport reaction. If this
                         a scalar then the same cost is used for all metabolites.
                         It can also be a vector of costs with the same dimension
                         as model.mets. Note that negative costs will result in that
                         transport of the metabolite is encouraged (opt, default 0.5)
   maxTime               maximum optimization time in minutes (opt,
                         default 15)
   plotResults           true if the result should be plotted during the
                         optimization (opt false)

   outModel              the resulting model structure
   geneLocalization      structure with the genes and their resulting
                         localization
   transportStruct       structure with the transport reactions that had
                         to be inferred and between which compartments
   scores                structure that contains the total score history
                         together with the score based on gene localization
                         and the score based on included transport reactions
   removedRxns           cell array with the reaction ids that had to be
                         removed in order to have a connected input model

   This function requires that the starting network is connected when it's in
   one compartment. Reactions that are unconnected are removed and saved
   in removedRxns. Try running fillGaps to have a more connected input
   model if there are many such reactions.

   In the final model all metabolites are produced in at least one reaction.
   This doesn't guarantee a fully functional model since there can be internal
   loops. Transport reactions are only included as passive diffusion (A &lt;=&gt; B).

   The score of a model is the sum of scores for all genes in their
   assigned compartment minus the cost of all transport reactions that
   had to be included. A gene can only be assigned to one compartment.
   This is a simplification to keep the problem size down. The problem is
   solved using simulated annealing.

   Usage: [outModel, geneLocalization, transportStruct, score, removedRxns]=...
       predictLocalization(model,GSS,defaultCompartment,transportCost,maxTime)

   Eduard Kerkhoven, 2018-07-25</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting)">addTransport</a>	addTransport</li><li><a href="convertToIrrev.html" class="code" title="function irrevModel=convertToIrrev(model,rxns)">convertToIrrev</a>	convertToIrrev</li><li><a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>	dispEM</li><li><a href="expandModel.html" class="code" title="function newModel=expandModel(model)">expandModel</a>	expandModel</li><li><a href="getExchangeRxns.html" class="code" title="function [exchangeRxns, exchangeRxnsIndexes]=getExchangeRxns(model,reactionType)">getExchangeRxns</a>	getExchangeRxns</li><li><a href="mergeCompartments.html" class="code" title="function [model, deletedRxns, duplicateRxns]=mergeCompartments(model,keepUnconstrained,deleteRxnsWithOneMet,distReverse)">mergeCompartments</a>	mergeCompartments</li><li><a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>	permuteModel</li><li><a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>	removeReactions</li><li><a href="standardizeGrRules.html" class="code" title="function [grRules,rxnGeneMat,indexes2check] = standardizeGrRules(model,embedded)">standardizeGrRules</a>	standardizeGrRules</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)</a></li><li><a href="#_sub2" class="code">function unconnected=findUnconnected(S,nEM,metsToCheck)</a></li><li><a href="#_sub3" class="code">function [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)</a></li><li><a href="#_sub4" class="code">function S=addTransport(S,nRxns,nER,nMets,nEM,nComps,metA,metB)</a></li><li><a href="#_sub5" class="code">function [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [outModel, geneLocalization, transportStruct, scores, removedRxns]=predictLocalization(model,GSS,defaultCompartment,transportCost,maxTime,plotResults)</a>
0002 <span class="comment">% predictLocalization</span>
0003 <span class="comment">%   Tries to assign reactions to compartments in a manner that is in</span>
0004 <span class="comment">%   agreement with localization predictors while at the same time</span>
0005 <span class="comment">%   maintaining connectivity.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%   model                 a model structure. If the model contains several</span>
0008 <span class="comment">%                         compartments they will be merged</span>
0009 <span class="comment">%   GSS                   gene scoring structure as from parseScores</span>
0010 <span class="comment">%   defaultCompartment    transport reactions are expressed as diffusion</span>
0011 <span class="comment">%                         between the defaultCompartment and the others.</span>
0012 <span class="comment">%                         This is usually the cytosol. The default</span>
0013 <span class="comment">%                         compartment must have a match in</span>
0014 <span class="comment">%                         GSS</span>
0015 <span class="comment">%   transportCost         the cost for including a transport reaction. If this</span>
0016 <span class="comment">%                         a scalar then the same cost is used for all metabolites.</span>
0017 <span class="comment">%                         It can also be a vector of costs with the same dimension</span>
0018 <span class="comment">%                         as model.mets. Note that negative costs will result in that</span>
0019 <span class="comment">%                         transport of the metabolite is encouraged (opt, default 0.5)</span>
0020 <span class="comment">%   maxTime               maximum optimization time in minutes (opt,</span>
0021 <span class="comment">%                         default 15)</span>
0022 <span class="comment">%   plotResults           true if the result should be plotted during the</span>
0023 <span class="comment">%                         optimization (opt false)</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%   outModel              the resulting model structure</span>
0026 <span class="comment">%   geneLocalization      structure with the genes and their resulting</span>
0027 <span class="comment">%                         localization</span>
0028 <span class="comment">%   transportStruct       structure with the transport reactions that had</span>
0029 <span class="comment">%                         to be inferred and between which compartments</span>
0030 <span class="comment">%   scores                structure that contains the total score history</span>
0031 <span class="comment">%                         together with the score based on gene localization</span>
0032 <span class="comment">%                         and the score based on included transport reactions</span>
0033 <span class="comment">%   removedRxns           cell array with the reaction ids that had to be</span>
0034 <span class="comment">%                         removed in order to have a connected input model</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%   This function requires that the starting network is connected when it's in</span>
0037 <span class="comment">%   one compartment. Reactions that are unconnected are removed and saved</span>
0038 <span class="comment">%   in removedRxns. Try running fillGaps to have a more connected input</span>
0039 <span class="comment">%   model if there are many such reactions.</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%   In the final model all metabolites are produced in at least one reaction.</span>
0042 <span class="comment">%   This doesn't guarantee a fully functional model since there can be internal</span>
0043 <span class="comment">%   loops. Transport reactions are only included as passive diffusion (A &lt;=&gt; B).</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%   The score of a model is the sum of scores for all genes in their</span>
0046 <span class="comment">%   assigned compartment minus the cost of all transport reactions that</span>
0047 <span class="comment">%   had to be included. A gene can only be assigned to one compartment.</span>
0048 <span class="comment">%   This is a simplification to keep the problem size down. The problem is</span>
0049 <span class="comment">%   solved using simulated annealing.</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%   Usage: [outModel, geneLocalization, transportStruct, score, removedRxns]=...</span>
0052 <span class="comment">%       predictLocalization(model,GSS,defaultCompartment,transportCost,maxTime)</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%   Eduard Kerkhoven, 2018-07-25</span>
0055 <span class="comment">%</span>
0056 
0057 <span class="keyword">if</span> nargin&lt;4
0058     transportCost=ones(numel(model.mets),1)*0.5;
0059 <span class="keyword">end</span>
0060 <span class="keyword">if</span> numel(transportCost)==1
0061     transportCost=ones(numel(model.mets),1)*transportCost;
0062 <span class="keyword">end</span>
0063 transportCost=transportCost(:);
0064 
0065 <span class="keyword">if</span> numel(transportCost)~=numel(model.mets)
0066     EM=<span class="string">'The vector of transport costs must have the same dimension as model.mets'</span>;
0067     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,true);
0068 <span class="keyword">end</span>
0069 <span class="keyword">if</span> nargin&lt;5
0070     maxTime=15;
0071 <span class="keyword">end</span>
0072 <span class="keyword">if</span> nargin&lt;6
0073     plotResults=false;
0074 <span class="keyword">end</span>
0075 
0076 <span class="keyword">if</span> isfield(model,<span class="string">'rxnComps'</span>)
0077     model=rmfield(model,<span class="string">'rxnComps'</span>);
0078     EM=<span class="string">'The model structure contains information about reaction compartmentalization. This is not supported by this function. The rxnComps field has been deleted'</span>;
0079     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0080 <span class="keyword">end</span>
0081 <span class="keyword">if</span> isfield(model,<span class="string">'geneComps'</span>)
0082     model=rmfield(model,<span class="string">'geneComps'</span>);
0083     EM=<span class="string">'The model structure contains information about gene compartmentalization. This is not supported by this function. The geneComps field has been deleted'</span>;
0084     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0085 <span class="keyword">end</span>
0086 
0087 I=ismember(defaultCompartment,GSS.compartments);
0088 <span class="keyword">if</span> I==false
0089     EM=<span class="string">'defaultCompartment not found in GSS'</span>;
0090     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM);
0091 <span class="keyword">end</span>
0092 
0093 <span class="keyword">if</span> numel(model.comps)&gt;1
0094     EM=<span class="string">'The model has several compartments. All compartments will be merged'</span>;
0095     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0096     model=<a href="mergeCompartments.html" class="code" title="function [model, deletedRxns, duplicateRxns]=mergeCompartments(model,keepUnconstrained,deleteRxnsWithOneMet,distReverse)">mergeCompartments</a>(model,true,true);
0097 <span class="keyword">end</span>
0098 
0099 <span class="comment">%***Begin formating the data structures</span>
0100 
0101 <span class="comment">%Expand the model so that iso-enzymes have different reactions</span>
0102 model=<a href="expandModel.html" class="code" title="function newModel=expandModel(model)">expandModel</a>(model);
0103 
0104 <span class="comment">%Identify reactions that have to be deleted because the involved mets are</span>
0105 <span class="comment">%never produced. This is done in an iterative manner</span>
0106 removedRxns={};
0107 <span class="comment">%This is to keep track of which metabolites are removed in this step. It is</span>
0108 <span class="comment">%needed to adjust the transport costs</span>
0109 originalModelMets=model.mets;
0110 <span class="keyword">while</span> 1
0111     irrevModel=<a href="convertToIrrev.html" class="code" title="function irrevModel=convertToIrrev(model,rxns)">convertToIrrev</a>(model);
0112     
0113     I=sum(irrevModel.S&gt;0,2);
0114     
0115     <span class="comment">%Pretend that the unconstrained metabolites are made enough</span>
0116     <span class="keyword">if</span> isfield(irrevModel,<span class="string">'unconstrained'</span>)
0117         I(irrevModel.unconstrained~=0)=2;
0118     <span class="keyword">end</span>
0119     metsToDelete=false(numel(model.mets),1);
0120     
0121     <span class="comment">%This is not very neat but I loop through each metabolite and check</span>
0122     <span class="comment">%whether it can be produced (without using only one isolated reversible</span>
0123     <span class="comment">%reaction)</span>
0124     <span class="keyword">for</span> i=1:numel(irrevModel.mets)
0125         <span class="comment">%If something can be made in two reactions then everything is fine.</span>
0126         <span class="comment">%If i can be made in one reaction it's fine unless it's through an</span>
0127         <span class="comment">%isolated reversible reaction (which can act as a mini loop)</span>
0128         <span class="keyword">if</span> I(i)&lt;2
0129             <span class="keyword">if</span> I(i)==1
0130                 <span class="comment">%Find the reaction where this metabolite is produced</span>
0131                 [~, J]=find(irrevModel.S(i,:)&gt;0);
0132                 
0133                 <span class="comment">%Check the metabolites that are consumed in this reaction.</span>
0134                 <span class="comment">%The problem is if any of them is only produced in the</span>
0135                 <span class="comment">%opposite reversible reaction</span>
0136                 K=irrevModel.S(:,J)&lt;0;
0137                 check=find(K &amp; I&lt;=1);
0138                 
0139                 <span class="keyword">for</span> j=1:numel(check)
0140                     <span class="comment">%Find the reactions where it participates</span>
0141                     [~, L]=find(irrevModel.S(check(j),:)&gt;0);
0142                     
0143                     <span class="keyword">if</span> ~isempty(L)
0144                         rxn=irrevModel.rxns(J);
0145                         rxnRev=irrevModel.rxns(L);
0146                         <span class="keyword">if</span> strcmp(strrep(rxn,<span class="string">'_REV'</span>,<span class="string">''</span>),strrep(rxnRev,<span class="string">'_REV'</span>,<span class="string">''</span>))
0147                             metsToDelete(i)=true;
0148                         <span class="keyword">end</span>
0149                     <span class="keyword">else</span>
0150                         <span class="comment">%If the metabolite was never produced then do</span>
0151                         <span class="comment">%nothing and deal with it when the loop gets there</span>
0152                         <span class="comment">%:)</span>
0153                         <span class="keyword">continue</span>;
0154                     <span class="keyword">end</span>
0155                 <span class="keyword">end</span>
0156             <span class="keyword">else</span>
0157                 <span class="comment">%Not made anywhere</span>
0158                 metsToDelete(i)=true;
0159             <span class="keyword">end</span>
0160         <span class="keyword">end</span>
0161     <span class="keyword">end</span>
0162     
0163     <span class="keyword">if</span> any(metsToDelete)
0164         <span class="comment">%Delete any reactions involving any of the metsToDelete</span>
0165         [~, I]=find(model.S(metsToDelete,:));
0166         removedRxns=[removedRxns;model.rxns(I)];
0167         model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,I,true,true);
0168     <span class="keyword">else</span>
0169         <span class="comment">%All bad reactions deleted</span>
0170         <span class="keyword">break</span>;
0171     <span class="keyword">end</span>
0172 <span class="keyword">end</span>
0173 
0174 <span class="comment">%Adjust the transport costs</span>
0175 transportCost=transportCost(ismember(originalModelMets,model.mets));
0176 
0177 <span class="comment">%Assign fake genes to reactions without genes. This is just to make things</span>
0178 <span class="comment">%easier later on</span>
0179 I=find(sum(model.rxnGeneMat,2)==0);
0180 <span class="keyword">for</span> i=1:numel(I)
0181     model.genes=[model.genes;[<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span> num2str(i)]];
0182     <span class="keyword">if</span> isfield(model,<span class="string">'geneShortNames'</span>)
0183         model.geneShortNames=[model.geneShortNames;{<span class="string">''</span>}];
0184     <span class="keyword">end</span>
0185     <span class="keyword">if</span> isfield(model,<span class="string">'geneMiriams'</span>)
0186         model.geneMiriams=[model.geneMiriams;{[]}];
0187     <span class="keyword">end</span>
0188     <span class="keyword">if</span> isfield(model,<span class="string">'geneFrom'</span>)
0189         model.geneFrom=[model.geneFrom;{{<span class="string">'FAKE'</span>}}];
0190     <span class="keyword">end</span>
0191     model.rxnGeneMat(I(i),numel(model.genes))=1;
0192     model.grRules{I(i)}=<span class="string">''</span>;
0193 <span class="keyword">end</span>
0194 
0195 <span class="comment">%Update the GSS. All genes, fake or real, for which there is no evidence</span>
0196 <span class="comment">%gets a score 0.5 in all compartments. Also just to make it easier further</span>
0197 <span class="comment">%on</span>
0198 I=setdiff(model.genes,GSS.genes);
0199 GSS.genes=[GSS.genes;I];
0200 GSS.scores=[GSS.scores;ones(numel(I),numel(GSS.compartments))*0.5];
0201 
0202 <span class="comment">%Gene complexes should be moved together in order to be biologically</span>
0203 <span class="comment">%relevant. The average score for the genes is used for each compartment.</span>
0204 <span class="comment">%This is done by changing the model so that gene complexes are used as a</span>
0205 <span class="comment">%single gene name and then a score is calculated for that &quot;gene&quot;.</span>
0206 
0207 <span class="comment">%Only &quot;and&quot;-relationships exist after expandModel</span>
0208 genes=unique(model.grRules);
0209 nGenes=strrep(genes,<span class="string">'('</span>,<span class="string">''</span>);
0210 nGenes=strrep(nGenes,<span class="string">')'</span>,<span class="string">''</span>);
0211 <span class="comment">%nGenes=strrep(nGenes,' and ','_and_');</span>
0212 complexes=setdiff(nGenes,model.genes);
0213 <span class="keyword">if</span> ~isempty(complexes)
0214     <span class="keyword">if</span> isempty(complexes{1}) <span class="comment">%Empty grRules also come up here</span>
0215         complexes(1)=[];
0216     <span class="keyword">end</span>
0217 <span class="keyword">end</span>
0218 cScores=zeros(numel(complexes),numel(GSS.compartments));
0219 <span class="keyword">for</span> i=1:numel(complexes)
0220     genesInComplex=regexp(complexes{i},<span class="string">' and '</span>,<span class="string">'split'</span>);
0221     
0222     <span class="comment">%Find these genes in GSS</span>
0223     [I, J]=ismember(genesInComplex,GSS.genes);
0224     
0225     <span class="keyword">if</span> any(I)
0226         <span class="comment">%Get the average of the genes that were found.</span>
0227         mScores=mean(GSS.scores(J(I),:));
0228         
0229         <span class="comment">%And add 0.5 for the genes that were not found in order to be</span>
0230         <span class="comment">%consistent with non-complexes</span>
0231         mScores=(mScores.*sum(I)+(numel(genesInComplex)-sum(I))*0.5)/numel(genesInComplex);
0232     <span class="keyword">else</span>
0233         EM=[<span class="string">'Could not parse grRule &quot;'</span> complexes{i} <span class="string">'&quot;. Assigning score 0.0 in all compartments'</span>];
0234         <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0235         mScores=ones(1,numel(genesInComplex))*0.5;
0236     <span class="keyword">end</span>
0237     cScores(i,:)=mScores;
0238     
0239     <span class="comment">%Add this complex as a new gene</span>
0240     model.genes=[model.genes;complexes{i}];
0241     <span class="keyword">if</span> isfield(model,<span class="string">'geneMiriams'</span>)
0242         model.geneMiriams=[model.geneMiriams;{[]}];
0243     <span class="keyword">end</span>
0244     <span class="keyword">if</span> isfield(model,<span class="string">'geneShortNames'</span>)
0245         model.geneShortNames=[model.geneShortNames;{<span class="string">''</span>}];
0246     <span class="keyword">end</span>
0247     <span class="keyword">if</span> isfield(model,<span class="string">'geneFrom'</span>)
0248         model.geneFrom=[model.geneFrom;{<span class="string">'COMPLEX'</span>}];
0249     <span class="keyword">end</span>
0250     <span class="comment">%Find the reactions which had the original complex and change them to</span>
0251     <span class="comment">%use the new &quot;gene&quot;</span>
0252     I=ismember(model.grRules,[<span class="string">'('</span> complexes{i} <span class="string">')'</span>]);
0253     
0254     <span class="comment">%Should check more carefully if there can be an error here</span>
0255     <span class="keyword">if</span> ~isempty(I)
0256         model.rxnGeneMat(I,:)=0; <span class="comment">%Ok since we have split on &quot;or&quot;</span>
0257         model.rxnGeneMat(I,numel(model.genes))=1;
0258     <span class="keyword">end</span>
0259 <span class="keyword">end</span>
0260 
0261 <span class="comment">%Add the new &quot;genes&quot;</span>
0262 GSS.genes=[GSS.genes;complexes];
0263 GSS.scores=[GSS.scores;cScores];
0264 
0265 <span class="comment">%After merging the complexes it could happen that there are genes that are</span>
0266 <span class="comment">%no longer in use. Delete such genes</span>
0267 model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,{},false,true);
0268 
0269 <span class="comment">%Exchange reactions, defined as involving an unconstrained metabolite, are</span>
0270 <span class="comment">%special in that they have to stay in the defaultCompartment. This means</span>
0271 <span class="comment">%that uptake/excretion of metabolites is always via the default</span>
0272 <span class="comment">%compartment. This is a small simplification, but should be valid in most</span>
0273 <span class="comment">%cases</span>
0274 [~, I]=<a href="getExchangeRxns.html" class="code" title="function [exchangeRxns, exchangeRxnsIndexes]=getExchangeRxns(model,reactionType)">getExchangeRxns</a>(model);
0275 
0276 <span class="comment">%It will be easier later on if the same place. Put them in the beginning</span>
0277 J=1:numel(model.rxns);
0278 J(I)=[];
0279 model=<a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>(model,[I;J'],<span class="string">'rxns'</span>);
0280 
0281 <span class="comment">%Number of exchange reactions</span>
0282 nER=numel(I);
0283 
0284 <span class="comment">%Also put the exchange metabolites in the beginning</span>
0285 <span class="keyword">if</span> isfield(model,<span class="string">'unconstrained'</span>)
0286     I=find(model.unconstrained);
0287     J=1:numel(model.mets);
0288     J(I)=[];
0289     model=<a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>(model,[I;J'],<span class="string">'mets'</span>);
0290     <span class="comment">%Also reorder the transport costs</span>
0291     transportCost=transportCost([I;J']);
0292     <span class="comment">%Number of exchange metabolites</span>
0293     nEM=numel(I);
0294 <span class="keyword">else</span>
0295     nEM=0;
0296 <span class="keyword">end</span>
0297 
0298 <span class="comment">%There is no point of having genes for exchange reactions, so delete them.</span>
0299 <span class="comment">%Also to make computations easier.</span>
0300 model.rxnGeneMat(1:nER,:)=0;
0301 model.grRules(1:nER)={<span class="string">''</span>};
0302 
0303 <span class="comment">%Remove unused genes</span>
0304 model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,{},false,true);
0305 
0306 <span class="comment">%Remove genes with no match to the model and reorder so that the genes are</span>
0307 <span class="comment">%in the same order as model.genes. Since we have already added fake genes</span>
0308 <span class="comment">%so that all genes in model exist in GSS it's fine to do like this.</span>
0309 [~, J]=ismember(model.genes,GSS.genes);
0310 GSS.genes=model.genes;
0311 GSS.scores=GSS.scores(J,:);
0312 
0313 <span class="comment">%Reorder the GSS so that the first index corresponds to the default</span>
0314 <span class="comment">%compartment</span>
0315 [~, J]=ismember(defaultCompartment,GSS.compartments);
0316 reorder=1:numel(GSS.compartments);
0317 reorder(J)=[];
0318 reorder=[J reorder];
0319 GSS.scores=GSS.scores(:,reorder);
0320 GSS.compartments=GSS.compartments(reorder);
0321 
0322 <span class="comment">%Since we're only looking at whether the metabolites can be synthesized, we</span>
0323 <span class="comment">%don't have to care about the stoichiometry. Change to -1/1 to simplify</span>
0324 <span class="comment">%later. Keep the S matrix for later though.</span>
0325 oldS=model.S;
0326 model.S(model.S&gt;0)=1;
0327 model.S(model.S&lt;0)=-1;
0328 
0329 <span class="comment">%Here I do a bit of a trick. Since I don't want to calculate which</span>
0330 <span class="comment">%reactions are reversible all the time, I let reversible reactions have the</span>
0331 <span class="comment">%coefficients -10/10 instead of -1/1</span>
0332 model.S(:,model.rev==1)=model.S(:,model.rev==1).*10;
0333 
0334 <span class="comment">%***Begin problem formulation</span>
0335 
0336 <span class="comment">%Some numbers that are good to have</span>
0337 nRxns=numel(model.rxns)-nER; <span class="comment">%Excluding exchange rxns</span>
0338 nMets=numel(model.mets)-nEM; <span class="comment">%Excluding exchange mets</span>
0339 nGenes=numel(model.genes);
0340 nComps=numel(GSS.compartments);
0341 
0342 <span class="comment">%Create a big stoichiometric matrix that will be the current model. In</span>
0343 <span class="comment">%order to have faster simulations the maximal model size is declared and</span>
0344 <span class="comment">%reactions are then moved within it.</span>
0345 
0346 <span class="comment">%First the original model (with the first nE being exchange rxns), then</span>
0347 <span class="comment">%reserve space for number of rxns minus exchange rxns for each non-default</span>
0348 <span class="comment">%compartment, then transport reactions for all non-exchange mets between</span>
0349 <span class="comment">%the default compartment and all others. NOTE: Kept eye()*0 since eye() can</span>
0350 <span class="comment">%be used to include all transport from the beginning</span>
0351 s=repmat(eye(nMets)*0,1,nComps-1);
0352 s=[zeros(numel(model.mets)-nMets,size(s,2));s];
0353 S=[model.S sparse(numel(model.mets),nRxns*(nComps-1)) s];
0354 s=[sparse(nMets*(nComps-1),numel(model.rxns)+nRxns*(nComps-1)) eye(nMets*(nComps-1))*0];
0355 S=[S;s];
0356 
0357 <span class="comment">%Also replicate the transport costs</span>
0358 transportCost=[transportCost(1:nEM);repmat(transportCost(nEM+1:end),nComps,1)];
0359 
0360 <span class="comment">%Create a binary matrix that says where the genes are in the current</span>
0361 <span class="comment">%solution</span>
0362 g2c=false(nGenes,nComps);
0363 <span class="comment">%All genes start in the default compartment</span>
0364 g2c(:,1)=true;
0365 
0366 <span class="comment">%Start of main optimization loop</span>
0367 tic;
0368 bestScore=-inf;
0369 bestS=[];
0370 bestg2c=[];
0371 
0372 <span class="comment">%Temp for testing</span>
0373 plotScore=[];
0374 nTrans=[];
0375 totScore=[];
0376 minScore=sum(min(GSS.scores,[],2));
0377 maxScore=sum(max(GSS.scores,[],2));
0378 
0379 <span class="keyword">while</span> toc&lt;maxTime*60
0380     <span class="comment">%Pick a random gene, weighted by it's current score minus the best</span>
0381     <span class="comment">%score for that gene (often 1.0, but can be 0.5 for no genes or average</span>
0382     <span class="comment">%for complexes. Genes with bad fits are more likely to be moved. This</span>
0383     <span class="comment">%formulation never moves a gene from its best compartment. Therefore a</span>
0384     <span class="comment">%small uniform weight is added.</span>
0385     [I, J]=find(g2c);
0386     geneToMove=randsample(nGenes,1,true,max(GSS.scores(I,:),[],2)-GSS.scores(sub2ind(size(g2c),I,J))+0.1);
0387     
0388     <span class="comment">%Sample among possible compartments to move to. Add a larger weight to</span>
0389     <span class="comment">%even out the odds a little. Also a way of getting rid of loops where</span>
0390     <span class="comment">%the same set of genes are moved back and forth several times.</span>
0391     toComp=randsample(nComps,1,true,GSS.scores(geneToMove,:)+0.2);
0392     
0393     <span class="comment">%Check that it moves to a new compartment</span>
0394     <span class="keyword">if</span> toComp==find(g2c(geneToMove,:))
0395         <span class="keyword">continue</span>;
0396     <span class="keyword">end</span>
0397     
0398     <span class="comment">%Moves the gene</span>
0399     [newS, newg2c]=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(S,model,g2c,geneToMove,toComp,nRxns,nMets);
0400     
0401     <span class="comment">%Tries to connect the network. If this was not possible in 10</span>
0402     <span class="comment">%iterations, then abort. If more than 20 modifications were needed then</span>
0403     <span class="comment">%it's unlikely that it will be a lower score</span>
0404     wasConnected=false;
0405     <span class="keyword">for</span> j=1:10
0406         <span class="comment">%Find the metabolites that are now unconnected</span>
0407         unconnected=<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS,nEM);
0408         
0409         <span class="comment">%Continue if there are still unconnected</span>
0410         <span class="keyword">if</span> any(unconnected)
0411             <span class="comment">%For each gene find out how many of these could be connected if</span>
0412             <span class="comment">%the gene was moved and how many would be disconnected by</span>
0413             <span class="comment">%moving that gene</span>
0414             [geneIndex, moveTo, deltaConnected, deltaScore]=<a href="#_sub3" class="code" title="subfunction [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)">selectGenes</a>(newS,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS);
0415             
0416             <span class="comment">%Score which gene would be the best to move. The highest</span>
0417             <span class="comment">%deltaScore is 1.0. I want it to be possible to move a gene</span>
0418             <span class="comment">%from worst to best compartment even if it disconnects, say,</span>
0419             <span class="comment">%1.5 more metabolites.</span>
0420             [score, I]=max(1.5*deltaScore+deltaConnected);
0421             
0422             <span class="comment">%Checks if it has to add a transport or if there is a gene that</span>
0423             <span class="comment">%could be moved order to have a more connected network</span>
0424             hasToAddTransport=true;
0425             <span class="keyword">if</span> ~isempty(deltaConnected)
0426                 <span class="keyword">if</span> score&gt;0
0427                     hasToAddTransport=false;
0428                 <span class="keyword">end</span>
0429             <span class="keyword">end</span>
0430             
0431             <span class="comment">%If it is possible to move any gene in order to have a more</span>
0432             <span class="comment">%connected network, then move the best one</span>
0433             <span class="keyword">if</span> hasToAddTransport==false;
0434                 [newS, newg2c]=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(newS,model,g2c,geneIndex(I),moveTo(I),nRxns,nMets);
0435             <span class="keyword">else</span>
0436                 <span class="comment">%Choose a random unconnected metabolite that should be</span>
0437                 <span class="comment">%connected</span>
0438                 transMet=unconnected(randsample(numel(unconnected),1));
0439                 
0440                 <span class="comment">%First get where the metabolite is now</span>
0441                 comps=ceil((transMet-nEM)/((size(S,1)-nEM)/nComps));
0442                 
0443                 <span class="comment">%Find the corresponding metabolite index if it were in the</span>
0444                 <span class="comment">%default compartment</span>
0445                 dcIndex=transMet-(comps-1)*nMets;
0446                 
0447                 <span class="comment">%Then get the indexes of that metabolite in all</span>
0448                 <span class="comment">%compartments</span>
0449                 allIndexes=dcIndex;
0450                 <span class="keyword">for</span> k=1:nComps-1
0451                     allIndexes=[allIndexes;dcIndex+nMets*k];
0452                 <span class="keyword">end</span>
0453                 
0454                 <span class="comment">%It could be that some of these aren't used in any</span>
0455                 <span class="comment">%reaction. Get only the ones which are</span>
0456                 I=sum(newS(allIndexes,:)~=0,2)&gt;0;
0457                 
0458                 <span class="comment">%Then get the ones that are used but not in unconnected.</span>
0459                 <span class="comment">%These are metabolites that could potentially be</span>
0460                 <span class="comment">%transported to connect transMet</span>
0461                 connectedUsed=setdiff(allIndexes(I),unconnected);
0462                 
0463                 <span class="comment">%I think this is an error but I leave it for now. It seems</span>
0464                 <span class="comment">%to happen if nothing can be connected in one step</span>
0465                 <span class="keyword">if</span> isempty(connectedUsed)
0466                     <span class="keyword">break</span>;
0467                 <span class="keyword">end</span>
0468                 
0469                 <span class="comment">%If transMet is in the default compartment then everything</span>
0470                 <span class="comment">%is fine, just connect it to a random one</span>
0471                 <span class="keyword">if</span> transMet==dcIndex
0472                     newS=<a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting)">addTransport</a>(newS,nRxns,nER,nMets,nEM,nComps,transMet,connectedUsed(randsample(numel(connectedUsed),1)));
0473                 <span class="keyword">else</span>
0474                     <span class="comment">%If one of the connectedUsed is in the default</span>
0475                     <span class="comment">%compartment then connect to that one</span>
0476                     I=connectedUsed(connectedUsed&lt;(nMets+nEM));
0477                     <span class="keyword">if</span> any(I)
0478                         newS=<a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting)">addTransport</a>(newS,nRxns,nER,nMets,nEM,nComps,transMet,I(randsample(numel(I),1)));
0479                     <span class="keyword">else</span>
0480                         <span class="comment">%This is if the only way to connect it is by adding</span>
0481                         <span class="comment">%two transport reactions, going via the default</span>
0482                         <span class="comment">%compartment</span>
0483                         <span class="keyword">break</span>;
0484                     <span class="keyword">end</span>
0485                 <span class="keyword">end</span>
0486             <span class="keyword">end</span>
0487         <span class="keyword">else</span>
0488             wasConnected=true;
0489             <span class="keyword">break</span>;
0490         <span class="keyword">end</span>
0491     <span class="keyword">end</span>
0492     
0493     <span class="comment">%If the network was connected in a new way, it is possible that some</span>
0494     <span class="comment">%transport reactions are no longer needed. They should be removed</span>
0495     <span class="keyword">if</span> wasConnected==true
0496         <span class="comment">%These are the metabolites that are being transported</span>
0497         activeTransport=find(sum(newS(:,nER+nRxns*nComps+1:end),2));
0498         
0499         <span class="comment">%Get the metabolites that are unconnected if transport wasn't used</span>
0500         unconnected=<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS(:,1:nER+nRxns*nComps),nEM);
0501         
0502         <span class="comment">%Find the transport reactions that are not needed and delete them</span>
0503         I=setdiff(activeTransport,unconnected);
0504         
0505         <span class="comment">%Since both metabolites in a transport rxns must be connected for</span>
0506         <span class="comment">%the reaction to be deleted, the sum over the colums should be 4.</span>
0507         newS(:,find(sum(newS(I,nER+nRxns*nComps+1:end))==4)+nER+nRxns*nComps)=0;
0508         
0509         <span class="comment">%Score the solution and determine whether to keep it as a new</span>
0510         <span class="comment">%solution</span>
0511         [score, geneScore, trCost]=<a href="#_sub5" class="code" title="subfunction [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)">scoreModel</a>(newS,newg2c,GSS,transportCost);
0512         
0513         <span class="comment">%If it was the best solution so far, keep it</span>
0514         <span class="keyword">if</span> score&gt;bestScore
0515             bestScore=score;
0516             bestS=newS;
0517             bestg2c=newg2c;
0518         <span class="keyword">end</span>
0519         
0520         <span class="comment">%This should not be steepest descent later</span>
0521         <span class="keyword">if</span> score&gt;=bestScore<span class="comment">% || exp((score-bestScore)*7)&gt;rand()</span>
0522             plotScore=[plotScore;geneScore];
0523             nTrans=[nTrans;trCost];
0524             totScore=[totScore;score];
0525             S=newS;
0526             g2c=newg2c;
0527             
0528             <span class="keyword">if</span> plotResults==true
0529                 subplot(3,2,1);
0530                 spy(S);
0531                 subplot(3,2,2);
0532                 plot(plotScore,<span class="string">'r'</span>);
0533                 xlabel(<span class="string">'Gene score'</span>);
0534                 subplot(3,2,3);
0535                 plot((plotScore-minScore)/(maxScore-minScore),<span class="string">'r'</span>);
0536                 xlabel(<span class="string">'Gene score relative to predictions'</span>);
0537                 subplot(3,2,4);
0538                 plot(nTrans,<span class="string">'g'</span>);
0539                 xlabel(<span class="string">'Transport cost'</span>);
0540                 subplot(3,2,5);
0541                 plot(totScore,<span class="string">'b'</span>);
0542                 xlabel(<span class="string">'Total score'</span>);
0543                 subplot(3,2,6);
0544                 pause(0.2);
0545             <span class="keyword">end</span>
0546         <span class="keyword">end</span>
0547     <span class="keyword">end</span>
0548 <span class="keyword">end</span>
0549 scores.totScore=score;
0550 scores.geneScore=geneScore;
0551 scores.transCost=trCost;
0552 
0553 <span class="comment">%Find which metabolites are transported and to where</span>
0554 [I, J]=find(bestS(nEM+1:nEM+nMets,end-nMets*(nComps-1)+1:end));
0555 J=ceil(J/nMets+1);
0556 transportStruct.mets=model.metNames(I+nEM);
0557 transportStruct.toComp=GSS.compartments(J);
0558 
0559 [I, J]=find(bestg2c);
0560 geneLocalization.genes=GSS.genes(I);
0561 geneLocalization.comps=GSS.compartments(J);
0562 
0563 <span class="comment">%Resort the gene names</span>
0564 [~, I]=sort(geneLocalization.genes);
0565 geneLocalization.genes=geneLocalization.genes(I);
0566 geneLocalization.comps=geneLocalization.comps(I);
0567 
0568 <span class="comment">%Remove the fake genes</span>
0569 I=strncmp(<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span>,geneLocalization.genes,8);
0570 geneLocalization.genes(I)=[];
0571 geneLocalization.comps(I)=[];
0572 
0573 <span class="comment">%Put together the model. This is done by first duplicating the S matrix</span>
0574 <span class="comment">%into the different compartments. Then the transport reactions are added</span>
0575 <span class="comment">%based on transportStruct. By now model.S should have the same size as the</span>
0576 <span class="comment">%S matrix used in the optimization, but with conserved stoichiometry. In</span>
0577 <span class="comment">%the final step all reactions and metabolites that aren't used in the S</span>
0578 <span class="comment">%matrix from the optimization are deleted from the model.</span>
0579 outModel=model;
0580 outModel.S=oldS;
0581 
0582 <span class="comment">%This is the S matrix without exchange rxns or metabolites</span>
0583 copyPart=outModel.S(nEM+1:<span class="keyword">end</span>,nER+1:end);
0584 
0585 <span class="comment">%Replicate to give the rxnGeneMat for the full system</span>
0586 copyRxnGeneMat=outModel.rxnGeneMat(nER+1:<span class="keyword">end</span>,:);
0587 outModel.rxnGeneMat=[outModel.rxnGeneMat;repmat(copyRxnGeneMat,nComps-1,1)];
0588 
0589 <span class="comment">%First fix the compartments. The model is already ordered with the exchange</span>
0590 <span class="comment">%metabolites first. The original model may contain one or two compartments,</span>
0591 <span class="comment">%depending on whether any exchange metabolites are defined.</span>
0592 nStartComps=numel(outModel.comps);
0593 <span class="keyword">if</span> nStartComps==1
0594     outModel.comps={<span class="string">'1'</span>};
0595     outModel.compNames=GSS.compartments(1);
0596 <span class="keyword">else</span>
0597     <span class="keyword">if</span> model.metComps(1)==1
0598         outModel.compNames(1)=GSS.compartments(1);
0599     <span class="keyword">else</span>
0600         outModel.compNames(2)=GSS.compartments(1);
0601     <span class="keyword">end</span>
0602 <span class="keyword">end</span>
0603 outModel.compNames=[outModel.compNames;GSS.compartments(2:end)];
0604 
0605 <span class="comment">%Ugly little loop</span>
0606 <span class="keyword">for</span> i=1:numel(GSS.compartments)-1
0607     outModel.comps=[outModel.comps;num2str(numel(outModel.comps)+1)];
0608 <span class="keyword">end</span>
0609 <span class="comment">%This information is not known from the data, so empty fields are added</span>
0610 outModel.compOutside=cell(numel(outModel.comps),1);
0611 outModel.compOutside(:)={<span class="string">''</span>};
0612 
0613 <span class="keyword">for</span> i=1:nComps-1
0614     outModel.S=[outModel.S sparse(size(outModel.S,1),nRxns)];
0615     outModel.S=[outModel.S;[sparse(nMets,nRxns*i+nER) copyPart]];
0616     outModel.rxns=[outModel.rxns;strcat(outModel.rxns(nER+1:nER+nRxns),<span class="string">'_'</span>,GSS.compartments{i+1})];
0617     outModel.rxnNames=[outModel.rxnNames;strcat(outModel.rxnNames(nER+1:nER+nRxns),<span class="string">' ('</span>,GSS.compartments{i+1},<span class="string">')'</span>)];
0618     outModel.lb=[outModel.lb;outModel.lb(nER+1:nER+nRxns)];
0619     outModel.ub=[outModel.ub;outModel.ub(nER+1:nER+nRxns)];
0620     outModel.rev=[outModel.rev;outModel.rev(nER+1:nER+nRxns)];
0621     outModel.c=[outModel.c;outModel.c(nER+1:nER+nRxns)];
0622     <span class="keyword">if</span> isfield(outModel,<span class="string">'grRules'</span>)
0623         outModel.grRules=[outModel.grRules;outModel.grRules(nER+1:nER+nRxns)];
0624     <span class="keyword">end</span>
0625     <span class="keyword">if</span> isfield(outModel,<span class="string">'subSystems'</span>)
0626         outModel.subSystems=[outModel.subSystems;outModel.subSystems(nER+1:nER+nRxns)];
0627     <span class="keyword">end</span>
0628     <span class="keyword">if</span> isfield(outModel,<span class="string">'eccodes'</span>)
0629         outModel.eccodes=[outModel.eccodes;outModel.eccodes(nER+1:nER+nRxns)];
0630     <span class="keyword">end</span>
0631     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnFrom'</span>)
0632         outModel.rxnFrom=[outModel.rxnFrom;outModel.rxnFrom(nER+1:nER+nRxns)];
0633     <span class="keyword">end</span>
0634     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnMiriams'</span>)
0635         outModel.rxnMiriams=[outModel.rxnMiriams;outModel.rxnMiriams(nER+1:nER+nRxns)];
0636     <span class="keyword">end</span>
0637     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnNotes'</span>)
0638         outModel.rxnNotes=[outModel.rxnNotes;outModel.rxnNotes(nER+1:nER+nRxns)];
0639     <span class="keyword">end</span>
0640     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnReferences'</span>)
0641         outModel.rxnReferences=[outModel.rxnReferences;outModel.rxnReferences(nER+1:nER+nRxns)];
0642     <span class="keyword">end</span>
0643     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnConfidenceScores'</span>)
0644         outModel.rxnConfidenceScores=[outModel.rxnConfidenceScores;outModel.rxnConfidenceScores(nER+1:nER+nRxns)];
0645     <span class="keyword">end</span>
0646     outModel.mets=[outModel.mets;strcat(outModel.mets(nEM+1:nEM+nMets),<span class="string">'_'</span>,GSS.compartments{i+1})];
0647     outModel.metNames=[outModel.metNames;outModel.metNames(nEM+1:nEM+nMets)];
0648     outModel.b=[outModel.b;outModel.b(nEM+1:nEM+nMets,:)];
0649     I=ones(nMets,1)*nStartComps+i;
0650     outModel.metComps=[outModel.metComps;I];
0651     <span class="keyword">if</span> isfield(outModel,<span class="string">'inchis'</span>)
0652         outModel.inchis=[outModel.inchis;outModel.inchis(nEM+1:nEM+nMets)];
0653     <span class="keyword">end</span>
0654     <span class="keyword">if</span> isfield(outModel,<span class="string">'unconstrained'</span>)
0655         outModel.unconstrained=[outModel.unconstrained;outModel.unconstrained(nEM+1:nEM+nMets)];
0656     <span class="keyword">end</span>
0657     <span class="keyword">if</span> isfield(outModel,<span class="string">'metMiriams'</span>)
0658         outModel.metMiriams=[outModel.metMiriams;outModel.metMiriams(nEM+1:nEM+nMets)];
0659     <span class="keyword">end</span>
0660     <span class="keyword">if</span> isfield(outModel,<span class="string">'metFormulas'</span>)
0661         outModel.metFormulas=[outModel.metFormulas;outModel.metFormulas(nEM+1:nEM+nMets)];
0662     <span class="keyword">end</span>
0663     <span class="keyword">if</span> isfield(outModel,<span class="string">'metFrom'</span>)
0664         outModel.metFrom=[outModel.metFrom;outModel.metFrom(nEM+1:nEM+nMets)];
0665     <span class="keyword">end</span>
0666     <span class="keyword">if</span> isfield(outModel,<span class="string">'metCharges'</span>)
0667         outModel.metCharges=[outModel.metCharges;outModel.metCharges(nEM+1:nEM+nMets)];
0668     <span class="keyword">end</span>
0669 <span class="keyword">end</span>
0670 
0671 <span class="comment">%Add the transport reactions</span>
0672 transS=bestS(:,numel(outModel.rxns)+1:end);
0673 J=sum(transS)&gt;0; <span class="comment">%Active rxns</span>
0674 
0675 <span class="comment">%Transport reactions are written in a different way compared to a &quot;real&quot;</span>
0676 <span class="comment">%stoichimetric matrix. This is to fix that</span>
0677 transS(transS~=0)=1;
0678 transS(1:nEM+nMets,:)=transS(1:nEM+nMets,:)*-1;
0679 I=find(sum(transS&gt;0,2));
0680 nTransRxns=numel(I);
0681 outModel.S=[outModel.S transS(:,J)];
0682 filler=ones(nTransRxns,1);
0683 outModel.lb=[outModel.lb;filler*-1000];
0684 outModel.ub=[outModel.ub;filler*1000];
0685 outModel.rev=[outModel.rev;filler];
0686 outModel.c=[outModel.c;filler*0];
0687 outModel.rxnGeneMat=[outModel.rxnGeneMat;sparse(nTransRxns,numel(outModel.genes))];
0688 
0689 <span class="keyword">for</span> i=1:numel(I)
0690     outModel.rxns=[outModel.rxns;strcat(<span class="string">'transport'</span>,num2str(i))];
0691     outModel.rxnNames=[outModel.rxnNames;[<span class="string">'Transport of '</span>,outModel.metNames{I(i)}]];
0692     <span class="keyword">if</span> isfield(outModel,<span class="string">'grRules'</span>)
0693         outModel.grRules=[outModel.grRules;{<span class="string">''</span>}];
0694     <span class="keyword">end</span>
0695     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnMiriams'</span>)
0696         outModel.rxnMiriams=[outModel.rxnMiriams;{[]}];
0697     <span class="keyword">end</span>
0698     <span class="keyword">if</span> isfield(outModel,<span class="string">'subSystems'</span>)
0699         outModel.subSystems=[outModel.subSystems;{<span class="string">'Inferred transport reactions'</span>}];
0700     <span class="keyword">end</span>
0701     <span class="keyword">if</span> isfield(outModel,<span class="string">'eccodes'</span>)
0702         outModel.eccodes=[outModel.eccodes;{<span class="string">''</span>}];
0703     <span class="keyword">end</span>
0704     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnFrom'</span>)
0705         outModel.rxnFrom=[outModel.rxnFrom;{<span class="string">''</span>}];
0706     <span class="keyword">end</span>
0707     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnNotes'</span>)
0708         outModel.rxnNotes=[outModel.rxnNotes;{<span class="string">''</span>}];
0709     <span class="keyword">end</span>
0710     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnReferences'</span>)
0711         outModel.rxnReferences=[outModel.rxnReferences;{<span class="string">''</span>}];
0712     <span class="keyword">end</span>
0713     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnConfidenceScores'</span>)
0714         outModel.rxnConfidenceScores=[outModel.rxnConfidenceScores;NaN];
0715     <span class="keyword">end</span>
0716 <span class="keyword">end</span>
0717 
0718 <span class="comment">%Then remove all reactions and metabolites that aren't used in the final</span>
0719 <span class="comment">%solution from the optimization</span>
0720 [~, J]=find(bestS(:,1:nER+nComps*nRxns));
0721 K=true(numel(outModel.rxns),1);
0722 K(J)=false;
0723 K(end-nTransRxns+1:end)=false;
0724 outModel=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(outModel,K,true);
0725 
0726 <span class="comment">%Remove all fake genes</span>
0727 I=strncmp(<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span>,outModel.genes,8);
0728 outModel.genes(I)=[];
0729 <span class="keyword">if</span> isfield(outModel,<span class="string">'geneMiriams'</span>)
0730     outModel.geneMiriams(I)=[];
0731 <span class="keyword">end</span>
0732 <span class="keyword">if</span> isfield(outModel,<span class="string">'geneShortNames'</span>)
0733     outModel.geneShortNames(I)=[];
0734 <span class="keyword">end</span>
0735 outModel.rxnGeneMat(:,I)=[];
0736 
0737 <span class="comment">%Fix grRules and reconstruct rxnGeneMat</span>
0738 [grRules,rxnGeneMat] = <a href="standardizeGrRules.html" class="code" title="function [grRules,rxnGeneMat,indexes2check] = standardizeGrRules(model,embedded)">standardizeGrRules</a>(outModel,true);
0739 outModel.grRules = grRules;
0740 outModel.rxnGeneMat = rxnGeneMat;
0741 <span class="keyword">end</span>
0742 
0743 <span class="comment">%Moves a gene and all associated reactions from one compartment to another</span>
0744 <a name="_sub1" href="#_subfunctions" class="code">function [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)</a>
0745 <span class="comment">%Find the current compartment and update to the new one</span>
0746 currentComp=find(g2c(geneToMove,:));
0747 g2c(geneToMove,:)=false;
0748 g2c(geneToMove,toComp)=true;
0749 
0750 <span class="comment">%Find the reactions in the original model that the gene controls</span>
0751 [I, ~]=find(model.rxnGeneMat(:,geneToMove));
0752 
0753 <span class="comment">%Calculate their current positions in the S matrix</span>
0754 oldRxns=I+(currentComp-1)*nRxns;
0755 
0756 <span class="comment">%And their new positions</span>
0757 newRxns=I+(toComp-1)*nRxns;
0758 
0759 <span class="comment">%The metabolite ids also have to be changed in order to match the new</span>
0760 <span class="comment">%compartment</span>
0761 metChange=nMets*(toComp-currentComp);
0762 
0763 <span class="comment">%Update the reactions</span>
0764 [I, J, K]=find(S(:,oldRxns));
0765 I=I+metChange;
0766 
0767 <span class="comment">%Move the reactions</span>
0768 S(:,oldRxns)=0;
0769 S(sub2ind(size(S),I,newRxns(J)))=K;
0770 <span class="keyword">end</span>
0771 
0772 <span class="comment">%Finds which metabolites are unconnected, in the sense that they are never</span>
0773 <span class="comment">%a product or only a product in a reversible reaction where one reactant is</span>
0774 <span class="comment">%only a product in the opposite direction of that reaction. This function</span>
0775 <span class="comment">%ignores exchange metabolites. Returns a vector of metabolite indexes.</span>
0776 <span class="comment">%metsToCheck is an array of metabolite indexes to check for connectivity.</span>
0777 <span class="comment">%If not supplied then all metabolites are checked</span>
0778 <a name="_sub2" href="#_subfunctions" class="code">function unconnected=findUnconnected(S,nEM,metsToCheck)</a>
0779 <span class="keyword">if</span> nargin&gt;2
0780     <span class="comment">%Do this by deleting everything from the network that is not in</span>
0781     <span class="comment">%metsToCheck and that is not exchange metabolites</span>
0782     I=false(size(S,1),1);
0783     I(1:nEM)=true;
0784     I(metsToCheck)=true;
0785     S=S(I,:);
0786 <span class="keyword">end</span>
0787 
0788 em=false(size(S,1),1);
0789 em(1:nEM)=true;
0790 
0791 <span class="comment">%Construct a matrix in which the reversible reactions are inverted</span>
0792 I=sum(S&gt;2,1) | sum(S&gt;2,1);
0793 revS=S;
0794 revS(:,I)=revS(:,I)*-1;
0795 
0796 <span class="comment">%First calculate the ones that are ok Produced in 2 rxns, is exchange, is</span>
0797 <span class="comment">%not used at all, is produced in non-reversible, involved in more than 1</span>
0798 <span class="comment">%reversible reactions</span>
0799 connected=sum(S&gt;0,2)&gt;1 | em | sum(S~=0,2)==0 | sum(S(:,~I)&gt;0,2)&gt;0 | sum(S(:,I)~=0,2)&gt;1;
0800 
0801 <span class="comment">%Then get the ones that are unconnected because they are never produced</span>
0802 unconnected=sum(S&gt;0 | revS&gt;0,2)==0 &amp; connected==false;
0803 
0804 <span class="comment">%Then get the ones that are potentially unconnected</span>
0805 maybeUnconnected=~connected &amp; ~unconnected;
0806 <span class="comment">%maybeUnconnected=find(maybeUnconnectedS);</span>
0807 
0808 <span class="comment">%The metabolites in maybeUnconnected are involved in one reversible</span>
0809 <span class="comment">%reaction and not produced in any other reaction. This means that the</span>
0810 <span class="comment">%reactions which have at least one met in maybeUnconnected as reactant and</span>
0811 <span class="comment">%one as product are unconnected. The metabolites in maybeUnconnected that</span>
0812 <span class="comment">%are present in those reactions are then dead ends</span>
0813 deadRxns=any(S(maybeUnconnected,:)&gt;0) &amp; any(S(maybeUnconnected,:)&lt;0);
0814 
0815 <span class="comment">%Get the mets involved in any of those reactions</span>
0816 problematic=any(S(:,deadRxns)~=0,2);
0817 
0818 <span class="comment">%If any of these are in the maybeUnconnected list then the metabolite is</span>
0819 <span class="comment">%unconnected</span>
0820 unconnected(problematic &amp; maybeUnconnected)=true;
0821 
0822 <span class="comment">%Map back to metsToCheck</span>
0823 <span class="keyword">if</span> nargin&gt;2
0824     unconnected=metsToCheck(unconnected(nEM+1:end));
0825 <span class="keyword">else</span>
0826     unconnected=find(unconnected);
0827 <span class="keyword">end</span>
0828 <span class="keyword">end</span>
0829 
0830 <span class="comment">%Given a set of unconnected metabolites, this function tries to move each</span>
0831 <span class="comment">%gene that could connect any of them, calculates the number of newly</span>
0832 <span class="comment">%connected metabolites minus the number of newly disconnected metabolites.</span>
0833 <span class="comment">%As some metabolites are very connected, only 25 genes are checked. Genes</span>
0834 <span class="comment">%that have a low score in their current compartment are more likely to be</span>
0835 <span class="comment">%moved.</span>
0836 <a name="_sub3" href="#_subfunctions" class="code">function [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)</a>
0837 <span class="comment">%If moveTo is 0 then the gene can't connect any of the metabolites</span>
0838 moveTo=zeros(numel(model.genes),1);
0839 deltaConnected=zeros(numel(model.genes),1);
0840 
0841 <span class="comment">%First get where the metabolites are now</span>
0842 nComps=size(g2c,2);
0843 comps=ceil((unconnected-nEM)/((size(S,1)-nEM)/nComps));
0844 
0845 <span class="comment">%Find the corresponding metabolite indexes if they all were in the default</span>
0846 <span class="comment">%compartment</span>
0847 dcIndexes=unique(unconnected-(comps-1)*nMets);
0848 
0849 <span class="comment">%Then find them if they were in any other compartment</span>
0850 allIndexes=dcIndexes;
0851 <span class="keyword">for</span> i=1:nComps-1
0852     allIndexes=[allIndexes;dcIndexes+nMets*i];
0853 <span class="keyword">end</span>
0854 
0855 <span class="comment">%Also check which reversible reactions that could be used</span>
0856 I=sum(S&gt;2,1) | sum(S&gt;2,1);
0857 revS=S;
0858 revS(:,I)=revS(:,I)*-1;
0859 
0860 <span class="comment">%Find all reactions that could make any of the unconnected metabolites in</span>
0861 <span class="comment">%some other compartment</span>
0862 newMets=setdiff(allIndexes,unconnected);
0863 [~, potential]=find(S(newMets,:)&gt;0 | revS(newMets,:)&gt;0);
0864 potential(potential&lt;=nER | potential&gt;nER+nRxns*nComps)=[]; <span class="comment">%No exchange rxns or transport rxns</span>
0865 
0866 <span class="comment">%Map J to the real metabolic reactions in model</span>
0867 rxnComps=ceil((potential-nER)/(nRxns));
0868 
0869 <span class="comment">%Find the corresponding reaction indexes if they all were in the default</span>
0870 <span class="comment">%compartment</span>
0871 dcRxnIndexes=potential-(rxnComps-1)*nRxns;
0872 
0873 <span class="comment">%Get the genes for those reactions</span>
0874 genes=find(sum(model.rxnGeneMat(dcRxnIndexes,:)&gt;0,1));
0875 
0876 <span class="comment">%For some cases there can be very many reactions to connect something. This</span>
0877 <span class="comment">%is in particular true in the beginning of the optimization if, say, ATP is</span>
0878 <span class="comment">%unconnected. Therefore limit the number of genes to be checked to 25.</span>
0879 <span class="comment">%Weigh so that genes with bad scores in their current compartment are more</span>
0880 <span class="comment">%likely to be moved</span>
0881 
0882 <span class="comment">%Get scores for these genes</span>
0883 [~, J]=find(g2c(genes,:));
0884 
0885 <span class="comment">%Add a small weight so that genes in their best compartment could be moved</span>
0886 <span class="comment">%as well</span>
0887 geneScores=GSS.scores(sub2ind(size(g2c),genes(:),J));
0888 modGeneScores=1.1-geneScores;
0889 <span class="keyword">if</span> numel(genes)&gt;25
0890     rGenes=genes(randsample(numel(genes),min(numel(genes),25),true,modGeneScores));
0891     
0892     <span class="comment">%The sampling with weights could give duplicates</span>
0893     rGenes=unique(rGenes);
0894     
0895     <span class="comment">%Reorder the geneScores to match</span>
0896     [~, I]=ismember(rGenes,genes);
0897     geneScores=geneScores(I);
0898     genes=rGenes;
0899 <span class="keyword">end</span>
0900 <span class="keyword">for</span> i=1:numel(genes)
0901     <span class="comment">%Since we are moving one gene at a time, only metabolites involved in</span>
0902     <span class="comment">%any of the reactions for that gene can become unconnected. We get them</span>
0903     <span class="comment">%so speed up the algorithm. First get all involved reactions in the</span>
0904     <span class="comment">%default compartment</span>
0905     rxns=find(model.rxnGeneMat(:,genes(i)));
0906     
0907     <span class="comment">%Then get their mets</span>
0908     mets=find(sum(model.S(:,rxns)~=0,2)&gt;0);
0909     
0910     <span class="comment">%Then get their indexes in all compartments</span>
0911     allIndexes=mets;
0912     <span class="keyword">for</span> j=1:nComps-1
0913         allIndexes=[allIndexes;mets+nMets*j];
0914     <span class="keyword">end</span>
0915     
0916     <span class="comment">%Check which of the unconnected metabolites that these reactions</span>
0917     <span class="comment">%correspond to. This could have been done earlier, but it's fast. I</span>
0918     <span class="comment">%skip the reversibility check because it's unlikely to be an issue</span>
0919     <span class="comment">%here. Worst case is that the gene is tested once to much</span>
0920     [I, ~]=find(model.S(:,rxns));
0921     moveToComps=unique(comps(ismember(dcIndexes,I)));
0922     
0923     <span class="comment">%Try to move the gene to each of the compartments</span>
0924     bestMove=-inf;
0925     bestComp=[];
0926     <span class="keyword">for</span> j=1:numel(moveToComps)
0927         newS=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(S,model,g2c,genes(i),moveToComps(j),nRxns,nMets);
0928         
0929         <span class="comment">%Check how many metabolites that are unconnected after moving the</span>
0930         <span class="comment">%gene</span>
0931         dConnected=numel(unconnected)-numel(<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS,nEM,[allIndexes;unconnected]));
0932         <span class="keyword">if</span> dConnected&gt;bestMove
0933             bestMove=dConnected;
0934             bestComp=moveToComps(j);
0935         <span class="keyword">end</span>
0936     <span class="keyword">end</span>
0937     
0938     <span class="comment">%Add the difference in connectivity and where the genes should be moved</span>
0939     moveTo(genes(i))=bestComp;
0940     deltaConnected(genes(i))=bestMove;
0941 <span class="keyword">end</span>
0942 
0943 <span class="comment">%Finish up</span>
0944 geneIndex=genes(:);
0945 moveTo=moveTo(geneIndex);
0946 deltaConnected=deltaConnected(geneIndex);
0947 deltaScore=GSS.scores(sub2ind(size(g2c),geneIndex(:),moveTo))-geneScores;
0948 <span class="keyword">end</span>
0949 
0950 <span class="comment">%Small function to add a transport reactions between two metabolites.</span>
0951 <span class="comment">%Transport reactions are written as having a coefficient 2.0 for both</span>
0952 <span class="comment">%reactant and product. This is not a &quot;real&quot; reaction, but since all normal</span>
0953 <span class="comment">%reaction have coefficient -1/1 or -10/10 it's a compact way of writing it.</span>
0954 <a name="_sub4" href="#_subfunctions" class="code">function S=addTransport(S,nRxns,nER,nMets,nEM,nComps,metA,metB)</a>
0955 mets=[metA;metB];
0956 <span class="comment">%Find the current compartments for the metabolites</span>
0957 comps=ceil((mets-nEM)/((size(S,1)-nEM)/nComps));
0958 
0959 <span class="keyword">if</span> sum(comps==1)~=1
0960     EM=<span class="string">'Tried to create a transport reaction from a non-default compartment'</span>;
0961     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM);
0962 <span class="keyword">end</span>
0963 
0964 <span class="comment">%Calculate the reaction index</span>
0965 rIndex=(nER+nRxns*nComps)+mets(comps~=1)-nEM-nMets;
0966 
0967 S(mets,rIndex)=2;
0968 <span class="keyword">end</span>
0969 
0970 <span class="comment">%Scores a network based on the localization of the genes and the number of</span>
0971 <span class="comment">%transporter reactions used.</span>
0972 <a name="_sub5" href="#_subfunctions" class="code">function [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)</a>
0973 [I, J]=find(g2c);
0974 geneScore=sum(GSS.scores(sub2ind(size(g2c),I,J)));
0975 [I, ~]=find(S==2);
0976 I=unique(I);
0977 transportCost=sum(transportCost(I));
0978 score=geneScore-transportCost;
0979 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 27-Sep-2018 11:46:32 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>