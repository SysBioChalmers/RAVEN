<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of predictLocalization</title>
  <meta name="keywords" content="predictLocalization">
  <meta name="description" content="predictLocalization">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">core</a> &gt; predictLocalization.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for core&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>predictLocalization
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>predictLocalization</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [outModel, geneLocalization, transportStruct, scores,removedRxns] = predictLocalization(model, GSS,defaultCompartment, transportCost, maxTime, plotResults) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> predictLocalization
    Tries to assign reactions to compartments in a manner that is in
    agreement with localization predictors while at the same time
    maintaining connectivity.

   Input:
    model                   a model structure. If the model contains
                           several compartments they will be merged
    GSS                     a gene scoring structure as from parseScores
    defaultCompartment      transport reactions are expressed as diffusion
                           between the defaultCompartment and the others.
                           This is usually the cytosol. The default
                           compartment must have a match in GSS
    transportCost           the cost for including a transport reaction. If
                           this a scalar then the same cost is used for
                           all metabolites. It can also be a vector of
                           costs with the same dimension as model.mets.
                           Note that negative costs will result in that
                           transport of the metabolite is encouraged (optional,
                           default 0.5)
    maxTime                 maximum optimization time in minutes (optional,
                           default 15)
    plotResults             true if the results should be plotted during the
                           optimization (optional, default false)

   Output:
    outModel                the resulting model structure
    geneLocalization        structure with the genes and their resulting
                           localization
    transportStruct         structure with the transport reactions that had
                           to be inferred and between which compartments
    scores                  structure that contains the total score history
                           together with the score based on gene
                           localization and the score based on included
                           transport reactions
    removedRxns             cell array with the reaction ids that had to be
                           removed in order to have a connected input
                           model

    This function requires that the starting network is connected when it
    is in one compartment. Reactions that are unconnected are removed and
    saved in removedRxns. Try running fillGaps to have a more connected
    input model if there are many such reactions. The input model should
    also not include any exchange, demand or sink reactions, otherwise this
    function would not provide any results.

    In the final model all metabolites are produced in at least one
    reaction. This does not guarantee a fully functional model since there
    can be internal loops. Transport reactions are only included as passive
    diffusion (A &lt;=&gt; B).

    The score of a model is the sum of scores for all genes in their
    assigned compartment minus the cost of all transport reactions that had
    to be included. A gene can only be assigned to one compartment. This is
    a simplification to keep the problem size down. The problem is solved
    using simulated annealing.

 Usage: [outModel, geneLocalization, transportStruct, scores,...
       removedRxns] = predictLocalization(model, GSS,...
       defaultCompartment, transportCost, maxTime, plotResults)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting,prefix)">addTransport</a>	addTransport</li><li><a href="convertToIrrev.html" class="code" title="function [irrevModel,matchRev,rev2irrev,irrev2rev]=convertToIrrev(model,rxns)">convertToIrrev</a>	convertToIrrev</li><li><a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>	dispEM</li><li><a href="expandModel.html" class="code" title="function [newModel, rxnToCheck]=expandModel(model)">expandModel</a>	expandModel</li><li><a href="getExchangeRxns.html" class="code" title="function [exchangeRxns, exchangeRxnsIndexes]=getExchangeRxns(model,reactionType)">getExchangeRxns</a>	getExchangeRxns</li><li><a href="mergeCompartments.html" class="code" title="function [model, deletedRxns, duplicateRxns]=mergeCompartments(model,keepUnconstrained,deleteRxnsWithOneMet,distReverse)">mergeCompartments</a>	mergeCompartments</li><li><a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>	permuteModel</li><li><a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>	removeReactions</li><li><a href="standardizeGrRules.html" class="code" title="function [grRules,rxnGeneMat,indexes2check] = standardizeGrRules(model,embedded)">standardizeGrRules</a>	standardizeGrRules</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)</a></li><li><a href="#_sub2" class="code">function unconnected=findUnconnected(S,nEM,metsToCheck)</a></li><li><a href="#_sub3" class="code">function [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)</a></li><li><a href="#_sub4" class="code">function S=addTransport(S,nRxns,nER,nMets,nEM,nComps,metA,metB)</a></li><li><a href="#_sub5" class="code">function [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)</a></li><li><a href="#_sub6" class="code">function y = randsample(n, k, replace, w)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [outModel, geneLocalization, transportStruct, scores,</a><span class="keyword">...</span>
0002     removedRxns] = predictLocalization(model, GSS,<span class="keyword">...</span>
0003     defaultCompartment, transportCost, maxTime, plotResults)
0004 <span class="comment">% predictLocalization</span>
0005 <span class="comment">%    Tries to assign reactions to compartments in a manner that is in</span>
0006 <span class="comment">%    agreement with localization predictors while at the same time</span>
0007 <span class="comment">%    maintaining connectivity.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   Input:</span>
0010 <span class="comment">%    model                   a model structure. If the model contains</span>
0011 <span class="comment">%                           several compartments they will be merged</span>
0012 <span class="comment">%    GSS                     a gene scoring structure as from parseScores</span>
0013 <span class="comment">%    defaultCompartment      transport reactions are expressed as diffusion</span>
0014 <span class="comment">%                           between the defaultCompartment and the others.</span>
0015 <span class="comment">%                           This is usually the cytosol. The default</span>
0016 <span class="comment">%                           compartment must have a match in GSS</span>
0017 <span class="comment">%    transportCost           the cost for including a transport reaction. If</span>
0018 <span class="comment">%                           this a scalar then the same cost is used for</span>
0019 <span class="comment">%                           all metabolites. It can also be a vector of</span>
0020 <span class="comment">%                           costs with the same dimension as model.mets.</span>
0021 <span class="comment">%                           Note that negative costs will result in that</span>
0022 <span class="comment">%                           transport of the metabolite is encouraged (optional,</span>
0023 <span class="comment">%                           default 0.5)</span>
0024 <span class="comment">%    maxTime                 maximum optimization time in minutes (optional,</span>
0025 <span class="comment">%                           default 15)</span>
0026 <span class="comment">%    plotResults             true if the results should be plotted during the</span>
0027 <span class="comment">%                           optimization (optional, default false)</span>
0028 <span class="comment">%</span>
0029 <span class="comment">%   Output:</span>
0030 <span class="comment">%    outModel                the resulting model structure</span>
0031 <span class="comment">%    geneLocalization        structure with the genes and their resulting</span>
0032 <span class="comment">%                           localization</span>
0033 <span class="comment">%    transportStruct         structure with the transport reactions that had</span>
0034 <span class="comment">%                           to be inferred and between which compartments</span>
0035 <span class="comment">%    scores                  structure that contains the total score history</span>
0036 <span class="comment">%                           together with the score based on gene</span>
0037 <span class="comment">%                           localization and the score based on included</span>
0038 <span class="comment">%                           transport reactions</span>
0039 <span class="comment">%    removedRxns             cell array with the reaction ids that had to be</span>
0040 <span class="comment">%                           removed in order to have a connected input</span>
0041 <span class="comment">%                           model</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%    This function requires that the starting network is connected when it</span>
0044 <span class="comment">%    is in one compartment. Reactions that are unconnected are removed and</span>
0045 <span class="comment">%    saved in removedRxns. Try running fillGaps to have a more connected</span>
0046 <span class="comment">%    input model if there are many such reactions. The input model should</span>
0047 <span class="comment">%    also not include any exchange, demand or sink reactions, otherwise this</span>
0048 <span class="comment">%    function would not provide any results.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%    In the final model all metabolites are produced in at least one</span>
0051 <span class="comment">%    reaction. This does not guarantee a fully functional model since there</span>
0052 <span class="comment">%    can be internal loops. Transport reactions are only included as passive</span>
0053 <span class="comment">%    diffusion (A &lt;=&gt; B).</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%    The score of a model is the sum of scores for all genes in their</span>
0056 <span class="comment">%    assigned compartment minus the cost of all transport reactions that had</span>
0057 <span class="comment">%    to be included. A gene can only be assigned to one compartment. This is</span>
0058 <span class="comment">%    a simplification to keep the problem size down. The problem is solved</span>
0059 <span class="comment">%    using simulated annealing.</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% Usage: [outModel, geneLocalization, transportStruct, scores,...</span>
0062 <span class="comment">%       removedRxns] = predictLocalization(model, GSS,...</span>
0063 <span class="comment">%       defaultCompartment, transportCost, maxTime, plotResults)</span>
0064 
0065 <span class="keyword">if</span> nargin&lt;4
0066     transportCost=ones(numel(model.mets),1)*0.5;
0067 <span class="keyword">end</span>
0068 <span class="keyword">if</span> numel(transportCost)==1
0069     transportCost=ones(numel(model.mets),1)*transportCost;
0070 <span class="keyword">end</span>
0071 transportCost=transportCost(:);
0072 
0073 <span class="keyword">if</span> numel(transportCost)~=numel(model.mets)
0074     EM=<span class="string">'The vector of transport costs must have the same dimension as model.mets'</span>;
0075     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,true);
0076 <span class="keyword">end</span>
0077 <span class="keyword">if</span> nargin&lt;5
0078     maxTime=15;
0079 <span class="keyword">end</span>
0080 <span class="keyword">if</span> nargin&lt;6
0081     plotResults=false;
0082 <span class="keyword">end</span>
0083 
0084 <span class="keyword">if</span> isfield(model,<span class="string">'rxnComps'</span>)
0085     model=rmfield(model,<span class="string">'rxnComps'</span>);
0086     EM=<span class="string">'The model structure contains information about reaction compartmentalization. This is not supported by this function. The rxnComps field has been deleted'</span>;
0087     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0088 <span class="keyword">end</span>
0089 <span class="keyword">if</span> isfield(model,<span class="string">'geneComps'</span>)
0090     model=rmfield(model,<span class="string">'geneComps'</span>);
0091     EM=<span class="string">'The model structure contains information about gene compartmentalization. This is not supported by this function. The geneComps field has been deleted'</span>;
0092     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0093 <span class="keyword">end</span>
0094 
0095 defaultCompartment=char(defaultCompartment);
0096 I=ismember(defaultCompartment,GSS.compartments);
0097 <span class="keyword">if</span> I==false
0098     EM=<span class="string">'defaultCompartment not found in GSS'</span>;
0099     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM);
0100 <span class="keyword">end</span>
0101 
0102 <span class="keyword">if</span> numel(model.comps)&gt;1
0103     EM=<span class="string">'The model has several compartments. All compartments will be merged'</span>;
0104     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0105     model=<a href="mergeCompartments.html" class="code" title="function [model, deletedRxns, duplicateRxns]=mergeCompartments(model,keepUnconstrained,deleteRxnsWithOneMet,distReverse)">mergeCompartments</a>(model,true,true);
0106 <span class="keyword">end</span>
0107 
0108 noGenes = ismember(model.genes,GSS.genes);
0109 <span class="keyword">if</span> ~all(noGenes)
0110     EM=[<span class="string">'For '</span> num2str(numel(find(~noGenes))) <span class="string">' of '</span> num2str(numel(model.genes)) <span class="string">' model genes no data was found in GSS'</span>];
0111     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0112 <span class="keyword">end</span>
0113 
0114 <span class="comment">%***Begin formating the data structures</span>
0115 
0116 <span class="comment">%Expand the model so that iso-enzymes have different reactions</span>
0117 model=<a href="expandModel.html" class="code" title="function [newModel, rxnToCheck]=expandModel(model)">expandModel</a>(model);
0118 
0119 <span class="comment">%Identify reactions that have to be deleted because the involved mets are</span>
0120 <span class="comment">%never produced. This is done in an iterative manner</span>
0121 removedRxns={};
0122 <span class="comment">%This is to keep track of which metabolites are removed in this step. It is</span>
0123 <span class="comment">%needed to adjust the transport costs</span>
0124 originalModelMets=model.mets;
0125 <span class="keyword">while</span> 1
0126     irrevModel=<a href="convertToIrrev.html" class="code" title="function [irrevModel,matchRev,rev2irrev,irrev2rev]=convertToIrrev(model,rxns)">convertToIrrev</a>(model);
0127     
0128     I=sum(irrevModel.S&gt;0,2);
0129     
0130     <span class="comment">%Pretend that the unconstrained metabolites are made enough</span>
0131     <span class="keyword">if</span> isfield(irrevModel,<span class="string">'unconstrained'</span>)
0132         I(irrevModel.unconstrained~=0)=2;
0133     <span class="keyword">end</span>
0134     metsToDelete=false(numel(model.mets),1);
0135     
0136     <span class="comment">%This is not very neat but iterate through each metabolite and check</span>
0137     <span class="comment">%whether it can be produced (without using only one isolated reversible</span>
0138     <span class="comment">%reaction)</span>
0139     <span class="keyword">for</span> i=1:numel(irrevModel.mets)
0140         <span class="comment">%If something can be made in two reactions then everything is fine.</span>
0141         <span class="comment">%If it can be made in one reaction it is fine unless it is through</span>
0142         <span class="comment">%an isolated reversible reaction (which can act as a mini loop)</span>
0143         <span class="keyword">if</span> I(i)&lt;2
0144             <span class="keyword">if</span> I(i)==1
0145                 <span class="comment">%Find the reaction where this metabolite is produced</span>
0146                 [~, J]=find(irrevModel.S(i,:)&gt;0);
0147                 
0148                 <span class="comment">%Check the metabolites that are consumed in this reaction.</span>
0149                 <span class="comment">%The problem is if any of them is only produced in the</span>
0150                 <span class="comment">%opposite reversible reaction</span>
0151                 K=irrevModel.S(:,J)&lt;0;
0152                 check=find(K &amp; I&lt;=1);
0153                 
0154                 <span class="keyword">for</span> j=1:numel(check)
0155                     <span class="comment">%Find the reactions where it participates</span>
0156                     [~, L]=find(irrevModel.S(check(j),:)&gt;0);
0157                     
0158                     <span class="keyword">if</span> ~isempty(L)
0159                         rxn=irrevModel.rxns(J);
0160                         rxnRev=irrevModel.rxns(L);
0161                         <span class="keyword">if</span> strcmp(strrep(rxn,<span class="string">'_REV'</span>,<span class="string">''</span>),strrep(rxnRev,<span class="string">'_REV'</span>,<span class="string">''</span>))
0162                             metsToDelete(i)=true;
0163                         <span class="keyword">end</span>
0164                     <span class="keyword">else</span>
0165                         <span class="comment">%If the metabolite was never produced then do</span>
0166                         <span class="comment">%nothing and deal with it when the loop gets there</span>
0167                         <span class="keyword">continue</span>;
0168                     <span class="keyword">end</span>
0169                 <span class="keyword">end</span>
0170             <span class="keyword">else</span>
0171                 <span class="comment">%Not made anywhere</span>
0172                 metsToDelete(i)=true;
0173             <span class="keyword">end</span>
0174         <span class="keyword">end</span>
0175     <span class="keyword">end</span>
0176     
0177     <span class="keyword">if</span> any(metsToDelete)
0178         <span class="comment">%Delete any reactions involving any of the metsToDelete</span>
0179         [~, I]=find(model.S(metsToDelete,:));
0180         removedRxns=[removedRxns;model.rxns(I)];
0181         model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,I,true,true);
0182     <span class="keyword">else</span>
0183         <span class="comment">%All bad reactions deleted</span>
0184         <span class="keyword">break</span>;
0185     <span class="keyword">end</span>
0186 <span class="keyword">end</span>
0187 
0188 <span class="comment">%Adjust the transport costs</span>
0189 transportCost=transportCost(ismember(originalModelMets,model.mets));
0190 
0191 <span class="comment">%Assign fake genes to reactions without genes. This is just to make things</span>
0192 <span class="comment">%easier later on</span>
0193 I=find(sum(model.rxnGeneMat,2)==0);
0194 <span class="keyword">for</span> i=1:numel(I)
0195     model.genes=[model.genes;[<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span> num2str(i)]];
0196     <span class="keyword">if</span> isfield(model,<span class="string">'geneShortNames'</span>)
0197         model.geneShortNames=[model.geneShortNames;{<span class="string">''</span>}];
0198     <span class="keyword">end</span>
0199     <span class="keyword">if</span> isfield(model,<span class="string">'geneMiriams'</span>)
0200         model.geneMiriams=[model.geneMiriams;{[]}];
0201     <span class="keyword">end</span>
0202     <span class="keyword">if</span> isfield(model,<span class="string">'proteinNames'</span>)
0203         model.proteinNames=[model.proteinNames;{[]}];
0204     <span class="keyword">end</span>
0205     <span class="keyword">if</span> isfield(model,<span class="string">'geneFrom'</span>)
0206         model.geneFrom=[model.geneFrom;{{<span class="string">'FAKE'</span>}}];
0207     <span class="keyword">end</span>
0208     model.rxnGeneMat(I(i),numel(model.genes))=1;
0209     model.grRules{I(i)}=<span class="string">''</span>;
0210 <span class="keyword">end</span>
0211 
0212 <span class="comment">%Update the GSS. All genes, fake or real, for which there is no evidence</span>
0213 <span class="comment">%gets a score 0.5 in all compartments. Also just to make it easier further</span>
0214 <span class="comment">%on</span>
0215 I=setdiff(model.genes,GSS.genes);
0216 GSS.genes=[GSS.genes;I];
0217 GSS.scores=[GSS.scores;ones(numel(I),numel(GSS.compartments))*0.5];
0218 
0219 <span class="comment">%Gene complexes should be moved together in order to be biologically</span>
0220 <span class="comment">%relevant. The average score for the genes is used for each compartment.</span>
0221 <span class="comment">%This is done by changing the model so that gene complexes are used as a</span>
0222 <span class="comment">%single gene name and then a score is calculated for that &quot;gene&quot;.</span>
0223 
0224 <span class="comment">%Only &quot;and&quot;-relationships exist after expandModel</span>
0225 genes=unique(model.grRules);
0226 nGenes=strrep(genes,<span class="string">'('</span>,<span class="string">''</span>);
0227 nGenes=strrep(nGenes,<span class="string">')'</span>,<span class="string">''</span>);
0228 <span class="comment">%nGenes=strrep(nGenes,' and ','_and_');</span>
0229 complexes=setdiff(nGenes,model.genes);
0230 <span class="keyword">if</span> ~isempty(complexes)
0231     <span class="keyword">if</span> isempty(complexes{1}) <span class="comment">%Empty grRules also come up here</span>
0232         complexes(1)=[];
0233     <span class="keyword">end</span>
0234 <span class="keyword">end</span>
0235 cScores=zeros(numel(complexes),numel(GSS.compartments));
0236 <span class="keyword">for</span> i=1:numel(complexes)
0237     genesInComplex=regexp(complexes{i},<span class="string">' and '</span>,<span class="string">'split'</span>);
0238     
0239     <span class="comment">%Find these genes in GSS</span>
0240     [I, J]=ismember(genesInComplex,GSS.genes);
0241     
0242     <span class="keyword">if</span> any(I)
0243         <span class="comment">%Get the average of the genes that were found</span>
0244         mScores=mean(GSS.scores(J(I),:));
0245         
0246         <span class="comment">%And add 0.5 for the genes that were not found in order to be</span>
0247         <span class="comment">%consistent with non-complexes</span>
0248         mScores=(mScores.*sum(I)+(numel(genesInComplex)-sum(I))*0.5)/numel(genesInComplex);
0249     <span class="keyword">else</span>
0250         EM=[<span class="string">'Could not parse grRule &quot;'</span> complexes{i} <span class="string">'&quot;. Assigning score 0.0 in all compartments'</span>];
0251         <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0252         mScores=ones(1,numel(genesInComplex))*0.5;
0253     <span class="keyword">end</span>
0254     cScores(i,:)=mScores;
0255     
0256     <span class="comment">%Add this complex as a new gene</span>
0257     model.genes=[model.genes;complexes{i}];
0258     <span class="keyword">if</span> isfield(model,<span class="string">'geneMiriams'</span>)
0259         model.geneMiriams=[model.geneMiriams;{[]}];
0260     <span class="keyword">end</span>
0261     <span class="keyword">if</span> isfield(model,<span class="string">'geneShortNames'</span>)
0262         model.geneShortNames=[model.geneShortNames;{<span class="string">''</span>}];
0263     <span class="keyword">end</span>
0264     <span class="keyword">if</span> isfield(model,<span class="string">'proteinNames'</span>)
0265         model.proteinNames=[model.proteinNames;{<span class="string">''</span>}];
0266     <span class="keyword">end</span>
0267     <span class="keyword">if</span> isfield(model,<span class="string">'geneFrom'</span>)
0268         model.geneFrom=[model.geneFrom;{<span class="string">'COMPLEX'</span>}];
0269     <span class="keyword">end</span>
0270     <span class="comment">%Find the reactions which had the original complex and change them to</span>
0271     <span class="comment">%use the new &quot;gene&quot;</span>
0272     I=ismember(model.grRules,[<span class="string">'('</span> complexes{i} <span class="string">')'</span>]);
0273     
0274     <span class="comment">%Should check more carefully if there can be an error here</span>
0275     <span class="keyword">if</span> ~isempty(I)
0276         model.rxnGeneMat(I,:)=0; <span class="comment">%Ok since the split on &quot;or&quot; was applied</span>
0277         model.rxnGeneMat(I,numel(model.genes))=1;
0278     <span class="keyword">end</span>
0279 <span class="keyword">end</span>
0280 
0281 <span class="comment">%Add the new &quot;genes&quot;</span>
0282 GSS.genes=[GSS.genes;complexes];
0283 GSS.scores=[GSS.scores;cScores];
0284 
0285 <span class="comment">%After merging the complexes it could happen that there are genes that are</span>
0286 <span class="comment">%no longer in use. Delete such genes</span>
0287 model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,{},false,true);
0288 
0289 <span class="comment">%Exchange reactions, defined as involving an unconstrained metabolite, are</span>
0290 <span class="comment">%special in that they have to stay in the defaultCompartment. This means</span>
0291 <span class="comment">%that uptake/excretion of metabolites is always via the default</span>
0292 <span class="comment">%compartment. This is a small simplification, but should be valid in most</span>
0293 <span class="comment">%cases</span>
0294 [~, I]=<a href="getExchangeRxns.html" class="code" title="function [exchangeRxns, exchangeRxnsIndexes]=getExchangeRxns(model,reactionType)">getExchangeRxns</a>(model);
0295 
0296 <span class="comment">%It will be easier later on if the same place. Put them in the beginning</span>
0297 J=1:numel(model.rxns);
0298 J(I)=[];
0299 model=<a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>(model,[I;J'],<span class="string">'rxns'</span>);
0300 
0301 <span class="comment">%Number of exchange reactions</span>
0302 nER=numel(I);
0303 
0304 <span class="comment">%Also put the exchange metabolites in the beginning</span>
0305 <span class="keyword">if</span> isfield(model,<span class="string">'unconstrained'</span>)
0306     I=find(model.unconstrained);
0307     J=1:numel(model.mets);
0308     J(I)=[];
0309     model=<a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>(model,[I;J'],<span class="string">'mets'</span>);
0310     <span class="comment">%Also reorder the transport costs</span>
0311     transportCost=transportCost([I;J']);
0312     <span class="comment">%Number of exchange metabolites</span>
0313     nEM=numel(I);
0314 <span class="keyword">else</span>
0315     nEM=0;
0316 <span class="keyword">end</span>
0317 
0318 <span class="comment">%There is no point of having genes for exchange reactions, so delete them.</span>
0319 <span class="comment">%Also to make computations easier</span>
0320 model.rxnGeneMat(1:nER,:)=0;
0321 model.grRules(1:nER)={<span class="string">''</span>};
0322 
0323 <span class="comment">%Remove unused genes</span>
0324 model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,{},false,true);
0325 
0326 <span class="comment">%Remove genes with no match to the model and reorder so that the genes are</span>
0327 <span class="comment">%in the same order as model.genes. Since the fake genes are already added</span>
0328 <span class="comment">%so that all genes in model exist in GSS it is fine to do like this</span>
0329 [~, J]=ismember(model.genes,GSS.genes);
0330 GSS.genes=model.genes;
0331 GSS.scores=GSS.scores(J,:);
0332 
0333 <span class="comment">%Reorder the GSS so that the first index corresponds to the default</span>
0334 <span class="comment">%compartment</span>
0335 [~, J]=ismember(defaultCompartment,GSS.compartments);
0336 reorder=1:numel(GSS.compartments);
0337 reorder(J)=[];
0338 reorder=[J reorder];
0339 GSS.scores=GSS.scores(:,reorder);
0340 GSS.compartments=GSS.compartments(reorder);
0341 
0342 <span class="comment">%Since it is only checked whether the metabolites can be synthesized, there</span>
0343 <span class="comment">%is no need to care about the stoichiometry. Change to -1/1 to simplify</span>
0344 <span class="comment">%later. Keep the S matrix for later though</span>
0345 oldS=model.S;
0346 model.S(model.S&gt;0)=1;
0347 model.S(model.S&lt;0)=-1;
0348 
0349 <span class="comment">%Here is a bit of a trick. To avoid the recurring calculation which</span>
0350 <span class="comment">%reactions are reversible, the reversible reactions have the coefficients</span>
0351 <span class="comment">%-10/10 instead of -1/1</span>
0352 model.S(:,model.rev==1)=model.S(:,model.rev==1).*10;
0353 
0354 <span class="comment">%***Begin problem formulation</span>
0355 
0356 <span class="comment">%Some numbers that are good to have</span>
0357 nRxns=numel(model.rxns)-nER; <span class="comment">%Excluding exchange rxns</span>
0358 nMets=numel(model.mets)-nEM; <span class="comment">%Excluding exchange mets</span>
0359 nGenes=numel(model.genes);
0360 nComps=numel(GSS.compartments);
0361 
0362 <span class="comment">%Create a big stoichiometric matrix that will be the current model. In</span>
0363 <span class="comment">%order to have faster simulations the maximal model size is declared and</span>
0364 <span class="comment">%reactions are then moved within it.</span>
0365 
0366 <span class="comment">%First the original model (with the first nE being exchange rxns), then</span>
0367 <span class="comment">%reserve space for number of rxns minus exchange rxns for each non-default</span>
0368 <span class="comment">%compartment, then transport reactions for all non-exchange mets between</span>
0369 <span class="comment">%the default compartment and all others.</span>
0370 <span class="comment">%NOTE: Kept eye()*0 since eye() can be used to include all transport from</span>
0371 <span class="comment">%the beginning</span>
0372 s=repmat(eye(nMets)*0,1,nComps-1);
0373 s=[zeros(numel(model.mets)-nMets,size(s,2));s];
0374 S=[model.S sparse(numel(model.mets),nRxns*(nComps-1)) s];
0375 s=[sparse(nMets*(nComps-1),numel(model.rxns)+nRxns*(nComps-1)) eye(nMets*(nComps-1))*0];
0376 S=[S;s];
0377 
0378 <span class="comment">%Also replicate the transport costs</span>
0379 transportCost=[transportCost(1:nEM);repmat(transportCost(nEM+1:end),nComps,1)];
0380 
0381 <span class="comment">%Create a binary matrix that says where the genes are in the current</span>
0382 <span class="comment">%solution</span>
0383 g2c=false(nGenes,nComps);
0384 <span class="comment">%All genes start in the default compartment</span>
0385 g2c(:,1)=true;
0386 
0387 <span class="comment">%Start of main optimization loop</span>
0388 tic;
0389 bestScore=-inf;
0390 bestS=[];
0391 bestg2c=[];
0392 
0393 <span class="comment">%Temp for testing</span>
0394 plotScore=[];
0395 nTrans=[];
0396 totScore=[];
0397 minScore=sum(min(GSS.scores,[],2));
0398 maxScore=sum(max(GSS.scores,[],2));
0399 
0400 <span class="keyword">while</span> toc&lt;maxTime*60
0401     <span class="comment">%Pick a random gene, weighted by it is current score minus the best</span>
0402     <span class="comment">%score for that gene (often 1.0, but can be 0.5 for no genes or average</span>
0403     <span class="comment">%for complexes). Genes with bad fits are more likely to be moved. This</span>
0404     <span class="comment">%formulation never moves a gene from its best compartment. Therefore a</span>
0405     <span class="comment">%small uniform weight is added</span>
0406     [I, J]=find(g2c);
0407     geneToMove=<a href="#_sub6" class="code" title="subfunction y = randsample(n, k, replace, w)">randsample</a>(nGenes,1,true,max(GSS.scores(I,:),[],2)-GSS.scores(sub2ind(size(g2c),I,J))+0.1);
0408     
0409     <span class="comment">%Sample among possible compartments to move to. Add a larger weight to</span>
0410     <span class="comment">%even out the odds a little. Also a way of getting rid of loops where</span>
0411     <span class="comment">%the same set of genes are moved back and forth several times</span>
0412     toComp=<a href="#_sub6" class="code" title="subfunction y = randsample(n, k, replace, w)">randsample</a>(nComps,1,true,GSS.scores(geneToMove,:)+0.2);
0413     
0414     <span class="comment">%Check that it moves to a new compartment</span>
0415     <span class="keyword">if</span> toComp==find(g2c(geneToMove,:))
0416         <span class="keyword">continue</span>;
0417     <span class="keyword">end</span>
0418     
0419     <span class="comment">%Moves the gene</span>
0420     [newS, newg2c]=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(S,model,g2c,geneToMove,toComp,nRxns,nMets);
0421     
0422     <span class="comment">%Tries to connect the network. If this was not possible in 10</span>
0423     <span class="comment">%iterations, then abort. If more than 20 modifications were needed then</span>
0424     <span class="comment">%it is unlikely that it will be a lower score</span>
0425     wasConnected=false;
0426     <span class="keyword">for</span> j=1:10
0427         <span class="comment">%Find the metabolites that are now unconnected</span>
0428         unconnected=<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS,nEM);
0429         
0430         <span class="comment">%Continue if there are still unconnected</span>
0431         <span class="keyword">if</span> any(unconnected)
0432             <span class="comment">%For each gene find out how many of these could be connected if</span>
0433             <span class="comment">%the gene was moved and how many would be disconnected by</span>
0434             <span class="comment">%moving that gene</span>
0435             [geneIndex, moveTo, deltaConnected, deltaScore]=<a href="#_sub3" class="code" title="subfunction [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)">selectGenes</a>(newS,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS);
0436             
0437             <span class="comment">%Score which gene would be the best to move. The highest</span>
0438             <span class="comment">%deltaScore is 1.0. It should be possible to move a gene from</span>
0439             <span class="comment">%worst to best compartment even if it disconnects, say, 1.5</span>
0440             <span class="comment">%more metabolites</span>
0441             [score, I]=max(1.5*deltaScore+deltaConnected);
0442             
0443             <span class="comment">%Check if it has to add a transport or if there is a gene that</span>
0444             <span class="comment">%could be moved order to have a more connected network</span>
0445             hasToAddTransport=true;
0446             <span class="keyword">if</span> ~isempty(deltaConnected)
0447                 <span class="keyword">if</span> score&gt;0
0448                     hasToAddTransport=false;
0449                 <span class="keyword">end</span>
0450             <span class="keyword">end</span>
0451             
0452             <span class="comment">%If it is possible to move any gene in order to have a more</span>
0453             <span class="comment">%connected network, then move the best one</span>
0454             <span class="keyword">if</span> hasToAddTransport==false
0455                 [newS, newg2c]=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(newS,model,g2c,geneIndex(I),moveTo(I),nRxns,nMets);
0456             <span class="keyword">else</span>
0457                 <span class="comment">%Choose a random unconnected metabolite that should be</span>
0458                 <span class="comment">%connected</span>
0459                 transMet=unconnected(<a href="#_sub6" class="code" title="subfunction y = randsample(n, k, replace, w)">randsample</a>(numel(unconnected),1));
0460                 
0461                 <span class="comment">%First get where the metabolite is now</span>
0462                 comps=ceil((transMet-nEM)/((size(S,1)-nEM)/nComps));
0463                 
0464                 <span class="comment">%Find the corresponding metabolite index if it were in the</span>
0465                 <span class="comment">%default compartment</span>
0466                 dcIndex=transMet-(comps-1)*nMets;
0467                 
0468                 <span class="comment">%Then get the indexes of that metabolite in all</span>
0469                 <span class="comment">%compartments</span>
0470                 allIndexes=dcIndex;
0471                 <span class="keyword">for</span> k=1:nComps-1
0472                     allIndexes=[allIndexes;dcIndex+nMets*k];
0473                 <span class="keyword">end</span>
0474                 
0475                 <span class="comment">%It could be that some of these are not used in any</span>
0476                 <span class="comment">%reaction. Get only the ones which are</span>
0477                 I=sum(newS(allIndexes,:)~=0,2)&gt;0;
0478                 
0479                 <span class="comment">%Then get the ones that are used but not in unconnected.</span>
0480                 <span class="comment">%These are metabolites that could potentially be</span>
0481                 <span class="comment">%transported to connect transMet</span>
0482                 connectedUsed=setdiff(allIndexes(I),unconnected);
0483                 
0484                 <span class="comment">%This may be an error but leave it for now. It seems to</span>
0485                 <span class="comment">%happen if nothing can be connected in one step</span>
0486                 <span class="keyword">if</span> isempty(connectedUsed)
0487                     <span class="keyword">break</span>;
0488                 <span class="keyword">end</span>
0489                 
0490                 <span class="comment">%If transMet is in the default compartment then everything</span>
0491                 <span class="comment">%is fine, just connect it to a random one</span>
0492                 <span class="keyword">if</span> transMet==dcIndex
0493                     newS=<a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting,prefix)">addTransport</a>(newS,nRxns,nER,nMets,nEM,nComps,transMet,connectedUsed(<a href="#_sub6" class="code" title="subfunction y = randsample(n, k, replace, w)">randsample</a>(numel(connectedUsed),1)));
0494                 <span class="keyword">else</span>
0495                     <span class="comment">%If one of the connectedUsed is in the default</span>
0496                     <span class="comment">%compartment then connect to that one</span>
0497                     I=connectedUsed(connectedUsed&lt;(nMets+nEM));
0498                     <span class="keyword">if</span> any(I)
0499                         newS=<a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting,prefix)">addTransport</a>(newS,nRxns,nER,nMets,nEM,nComps,transMet,I(<a href="#_sub6" class="code" title="subfunction y = randsample(n, k, replace, w)">randsample</a>(numel(I),1)));
0500                     <span class="keyword">else</span>
0501                         <span class="comment">%This is if the only way to connect it is by adding</span>
0502                         <span class="comment">%two transport reactions, going via the default</span>
0503                         <span class="comment">%compartment</span>
0504                         <span class="keyword">break</span>;
0505                     <span class="keyword">end</span>
0506                 <span class="keyword">end</span>
0507             <span class="keyword">end</span>
0508         <span class="keyword">else</span>
0509             wasConnected=true;
0510             <span class="keyword">break</span>;
0511         <span class="keyword">end</span>
0512     <span class="keyword">end</span>
0513     
0514     <span class="comment">%If the network was connected in a new way, it is possible that some</span>
0515     <span class="comment">%transport reactions are no longer needed. They should be removed</span>
0516     <span class="keyword">if</span> wasConnected==true
0517         <span class="comment">%These are the metabolites that are being transported</span>
0518         activeTransport=find(sum(newS(:,nER+nRxns*nComps+1:end),2));
0519         
0520         <span class="comment">%Get the metabolites that are unconnected if transport was not used</span>
0521         unconnected=<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS(:,1:nER+nRxns*nComps),nEM);
0522         
0523         <span class="comment">%Find the transport reactions that are not needed and delete them</span>
0524         I=setdiff(activeTransport,unconnected);
0525         
0526         <span class="comment">%Since both metabolites in a transport rxns must be connected for</span>
0527         <span class="comment">%the reaction to be deleted, the sum over the colums should be 4</span>
0528         newS(:,find(sum(newS(I,nER+nRxns*nComps+1:end))==4)+nER+nRxns*nComps)=0;
0529         
0530         <span class="comment">%Score the solution and determine whether to keep it as a new</span>
0531         <span class="comment">%solution</span>
0532         [score, geneScore, trCost]=<a href="#_sub5" class="code" title="subfunction [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)">scoreModel</a>(newS,newg2c,GSS,transportCost);
0533         
0534         <span class="comment">%If it was the best solution so far, keep it</span>
0535         <span class="keyword">if</span> score&gt;bestScore
0536             bestScore=score;
0537             bestS=newS;
0538             bestg2c=newg2c;
0539         <span class="keyword">end</span>
0540         
0541         <span class="comment">%This should not be steepest descent later</span>
0542         <span class="keyword">if</span> score&gt;=bestScore<span class="comment">% || exp((score-bestScore)*7)&gt;rand()</span>
0543             plotScore=[plotScore;geneScore];
0544             nTrans=[nTrans;trCost];
0545             totScore=[totScore;score];
0546             S=newS;
0547             g2c=newg2c;
0548             
0549             <span class="keyword">if</span> plotResults==true
0550                 subplot(3,2,1);
0551                 spy(S);
0552                 subplot(3,2,2);
0553                 plot(plotScore,<span class="string">'r'</span>);
0554                 xlabel(<span class="string">'Gene score'</span>);
0555                 subplot(3,2,3);
0556                 plot((plotScore-minScore)/(maxScore-minScore),<span class="string">'r'</span>);
0557                 xlabel(<span class="string">'Gene score relative to predictions'</span>);
0558                 subplot(3,2,4);
0559                 plot(nTrans,<span class="string">'g'</span>);
0560                 xlabel(<span class="string">'Transport cost'</span>);
0561                 subplot(3,2,5);
0562                 plot(totScore,<span class="string">'b'</span>);
0563                 xlabel(<span class="string">'Total score'</span>);
0564                 subplot(3,2,6);
0565                 pause(0.2);
0566             <span class="keyword">end</span>
0567         <span class="keyword">end</span>
0568     <span class="keyword">end</span>
0569 <span class="keyword">end</span>
0570 scores.totScore=score;
0571 scores.geneScore=geneScore;
0572 scores.transCost=trCost;
0573 
0574 <span class="comment">%Find which metabolites are transported and to where</span>
0575 [I, J]=find(bestS(nEM+1:nEM+nMets,end-nMets*(nComps-1)+1:end));
0576 J=ceil(J/nMets+1);
0577 transportStruct.mets=model.metNames(I+nEM);
0578 transportStruct.toComp=GSS.compartments(J);
0579 
0580 [I, J]=find(bestg2c);
0581 geneLocalization.genes=GSS.genes(I);
0582 geneLocalization.comps=GSS.compartments(J);
0583 
0584 <span class="comment">%Resort the gene names</span>
0585 [~, I]=sort(geneLocalization.genes);
0586 geneLocalization.genes=geneLocalization.genes(I);
0587 geneLocalization.comps=geneLocalization.comps(I);
0588 
0589 <span class="comment">%Remove the fake genes</span>
0590 I=strncmp(<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span>,geneLocalization.genes,8);
0591 geneLocalization.genes(I)=[];
0592 geneLocalization.comps(I)=[];
0593 
0594 <span class="comment">%Put together the model. This is done by first duplicating the S matrix</span>
0595 <span class="comment">%into the different compartments. Then the transport reactions are added</span>
0596 <span class="comment">%based on transportStruct. By now model.S should have the same size as the</span>
0597 <span class="comment">%S matrix used in the optimization, but with conserved stoichiometry. In</span>
0598 <span class="comment">%the final step all reactions and metabolites that are not used in the S</span>
0599 <span class="comment">%matrix from the optimization are deleted from the model</span>
0600 outModel=model;
0601 outModel.S=oldS;
0602 
0603 <span class="comment">%This is the S matrix without exchange rxns or metabolites</span>
0604 copyPart=outModel.S(nEM+1:<span class="keyword">end</span>,nER+1:end);
0605 
0606 <span class="comment">%Replicate to give the rxnGeneMat for the full system</span>
0607 copyRxnGeneMat=outModel.rxnGeneMat(nER+1:<span class="keyword">end</span>,:);
0608 outModel.rxnGeneMat=[outModel.rxnGeneMat;repmat(copyRxnGeneMat,nComps-1,1)];
0609 
0610 <span class="comment">%First fix the compartments. The model is already ordered with the exchange</span>
0611 <span class="comment">%metabolites first. The original model may contain one or two compartments,</span>
0612 <span class="comment">%depending on whether any exchange metabolites are defined</span>
0613 nStartComps=numel(outModel.comps);
0614 <span class="keyword">if</span> nStartComps==1
0615     outModel.comps={<span class="string">'1'</span>};
0616     outModel.compNames=GSS.compartments(1);
0617 <span class="keyword">else</span>
0618     <span class="keyword">if</span> model.metComps(1)==1
0619         outModel.compNames(1)=GSS.compartments(1);
0620     <span class="keyword">else</span>
0621         outModel.compNames(2)=GSS.compartments(1);
0622     <span class="keyword">end</span>
0623 <span class="keyword">end</span>
0624 outModel.compNames=[outModel.compNames;GSS.compartments(2:end)'];
0625 
0626 <span class="comment">%Ugly little loop</span>
0627 <span class="keyword">for</span> i=1:numel(GSS.compartments)-1
0628     outModel.comps=[outModel.comps;num2str(numel(outModel.comps)+1)];
0629 <span class="keyword">end</span>
0630 <span class="comment">%This information is not known from the data, so empty fields are added</span>
0631 outModel.compOutside=cell(numel(outModel.comps),1);
0632 outModel.compOutside(:)={<span class="string">''</span>};
0633 
0634 <span class="keyword">for</span> i=1:nComps-1
0635     outModel.S=[outModel.S sparse(size(outModel.S,1),nRxns)];
0636     outModel.S=[outModel.S;[sparse(nMets,nRxns*i+nER) copyPart]];
0637     outModel.rxns=[outModel.rxns;strcat(outModel.rxns(nER+1:nER+nRxns),<span class="string">'_'</span>,GSS.compartments{i+1})];
0638     outModel.rxnNames=[outModel.rxnNames;strcat(outModel.rxnNames(nER+1:nER+nRxns),<span class="string">' ('</span>,GSS.compartments{i+1},<span class="string">')'</span>)];
0639     outModel.lb=[outModel.lb;outModel.lb(nER+1:nER+nRxns)];
0640     outModel.ub=[outModel.ub;outModel.ub(nER+1:nER+nRxns)];
0641     outModel.rev=[outModel.rev;outModel.rev(nER+1:nER+nRxns)];
0642     outModel.c=[outModel.c;outModel.c(nER+1:nER+nRxns)];
0643     <span class="keyword">if</span> isfield(outModel,<span class="string">'grRules'</span>)
0644         outModel.grRules=[outModel.grRules;outModel.grRules(nER+1:nER+nRxns)];
0645     <span class="keyword">end</span>
0646     <span class="keyword">if</span> isfield(outModel,<span class="string">'subSystems'</span>)
0647         outModel.subSystems=[outModel.subSystems;outModel.subSystems(nER+1:nER+nRxns)];
0648     <span class="keyword">end</span>
0649     <span class="keyword">if</span> isfield(outModel,<span class="string">'eccodes'</span>)
0650         outModel.eccodes=[outModel.eccodes;outModel.eccodes(nER+1:nER+nRxns)];
0651     <span class="keyword">end</span>
0652     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnFrom'</span>)
0653         outModel.rxnFrom=[outModel.rxnFrom;outModel.rxnFrom(nER+1:nER+nRxns)];
0654     <span class="keyword">end</span>
0655     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnMiriams'</span>)
0656         outModel.rxnMiriams=[outModel.rxnMiriams;outModel.rxnMiriams(nER+1:nER+nRxns)];
0657     <span class="keyword">end</span>
0658     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnNotes'</span>)
0659         outModel.rxnNotes=[outModel.rxnNotes;outModel.rxnNotes(nER+1:nER+nRxns)];
0660     <span class="keyword">end</span>
0661     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnReferences'</span>)
0662         outModel.rxnReferences=[outModel.rxnReferences;outModel.rxnReferences(nER+1:nER+nRxns)];
0663     <span class="keyword">end</span>
0664     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnConfidenceScores'</span>)
0665         outModel.rxnConfidenceScores=[outModel.rxnConfidenceScores;outModel.rxnConfidenceScores(nER+1:nER+nRxns)];
0666     <span class="keyword">end</span>
0667     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnDeltaG'</span>)
0668         outModel.rxnDeltaG=[outModel.rxnDeltaG;outModel.rxnDeltaG(nER+1:nER+nRxns)];
0669     <span class="keyword">end</span>
0670     outModel.mets=[outModel.mets;strcat(outModel.mets(nEM+1:nEM+nMets),<span class="string">'_'</span>,GSS.compartments{i+1})];
0671     outModel.metNames=[outModel.metNames;outModel.metNames(nEM+1:nEM+nMets)];
0672     outModel.b=[outModel.b;outModel.b(nEM+1:nEM+nMets,:)];
0673     I=ones(nMets,1)*nStartComps+i;
0674     outModel.metComps=[outModel.metComps;I];
0675     <span class="keyword">if</span> isfield(outModel,<span class="string">'inchis'</span>)
0676         outModel.inchis=[outModel.inchis;outModel.inchis(nEM+1:nEM+nMets)];
0677     <span class="keyword">end</span>
0678     <span class="keyword">if</span> isfield(outModel,<span class="string">'metSmiles'</span>)
0679         outModel.metSmiles=[outModel.metSmiles;outModel.metSmiles(nEM+1:nEM+nMets)];
0680     <span class="keyword">end</span>
0681     <span class="keyword">if</span> isfield(outModel,<span class="string">'unconstrained'</span>)
0682         outModel.unconstrained=[outModel.unconstrained;outModel.unconstrained(nEM+1:nEM+nMets)];
0683     <span class="keyword">end</span>
0684     <span class="keyword">if</span> isfield(outModel,<span class="string">'metMiriams'</span>)
0685         outModel.metMiriams=[outModel.metMiriams;outModel.metMiriams(nEM+1:nEM+nMets)];
0686     <span class="keyword">end</span>
0687     <span class="keyword">if</span> isfield(outModel,<span class="string">'metFormulas'</span>)
0688         outModel.metFormulas=[outModel.metFormulas;outModel.metFormulas(nEM+1:nEM+nMets)];
0689     <span class="keyword">end</span>
0690     <span class="keyword">if</span> isfield(outModel,<span class="string">'metFrom'</span>)
0691         outModel.metFrom=[outModel.metFrom;outModel.metFrom(nEM+1:nEM+nMets)];
0692     <span class="keyword">end</span>
0693     <span class="keyword">if</span> isfield(outModel,<span class="string">'metCharges'</span>)
0694         outModel.metCharges=[outModel.metCharges;outModel.metCharges(nEM+1:nEM+nMets)];
0695     <span class="keyword">end</span>
0696     <span class="keyword">if</span> isfield(outModel,<span class="string">'metDeltaG'</span>)
0697         outModel.metDeltaG=[outModel.metDeltaG;outModel.metDeltaG(nEM+1:nEM+nMets)];
0698     <span class="keyword">end</span>
0699 <span class="keyword">end</span>
0700 
0701 <span class="comment">%Add the transport reactions</span>
0702 transS=bestS(:,numel(outModel.rxns)+1:end);
0703 J=sum(transS)&gt;0; <span class="comment">%Active rxns</span>
0704 
0705 <span class="comment">%Transport reactions are written in a different way compared to a &quot;real&quot;</span>
0706 <span class="comment">%stoichimetric matrix. This is to fix that</span>
0707 transS(transS~=0)=1;
0708 transS(1:nEM+nMets,:)=transS(1:nEM+nMets,:)*-1;
0709 I=find(sum(transS&gt;0,2));
0710 nTransRxns=numel(I);
0711 outModel.S=[outModel.S transS(:,J)];
0712 filler=ones(nTransRxns,1);
0713 outModel.lb=[outModel.lb;filler*-1000];
0714 outModel.ub=[outModel.ub;filler*1000];
0715 outModel.rev=[outModel.rev;filler];
0716 outModel.c=[outModel.c;filler*0];
0717 outModel.rxnGeneMat=[outModel.rxnGeneMat;sparse(nTransRxns,numel(outModel.genes))];
0718 
0719 <span class="keyword">for</span> i=1:numel(I)
0720     outModel.rxns=[outModel.rxns;strcat(<span class="string">'transport'</span>,num2str(i))];
0721     outModel.rxnNames=[outModel.rxnNames;[<span class="string">'Transport of '</span>,outModel.metNames{I(i)}]];
0722     <span class="keyword">if</span> isfield(outModel,<span class="string">'grRules'</span>)
0723         outModel.grRules=[outModel.grRules;{<span class="string">''</span>}];
0724     <span class="keyword">end</span>
0725     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnMiriams'</span>)
0726         outModel.rxnMiriams=[outModel.rxnMiriams;{[]}];
0727     <span class="keyword">end</span>
0728     <span class="keyword">if</span> isfield(outModel,<span class="string">'subSystems'</span>)
0729         outModel.subSystems=[outModel.subSystems;{{<span class="string">'Inferred transport reactions'</span>}}];
0730     <span class="keyword">end</span>
0731     <span class="keyword">if</span> isfield(outModel,<span class="string">'eccodes'</span>)
0732         outModel.eccodes=[outModel.eccodes;{<span class="string">''</span>}];
0733     <span class="keyword">end</span>
0734     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnFrom'</span>)
0735         outModel.rxnFrom=[outModel.rxnFrom;{<span class="string">''</span>}];
0736     <span class="keyword">end</span>
0737     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnNotes'</span>)
0738         outModel.rxnNotes=[outModel.rxnNotes;{<span class="string">''</span>}];
0739     <span class="keyword">end</span>
0740     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnReferences'</span>)
0741         outModel.rxnReferences=[outModel.rxnReferences;{<span class="string">''</span>}];
0742     <span class="keyword">end</span>
0743     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnConfidenceScores'</span>)
0744         outModel.rxnConfidenceScores=[outModel.rxnConfidenceScores;NaN];
0745     <span class="keyword">end</span>
0746     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnDeltaG'</span>)
0747         outModel.rxnDeltaG=[outModel.rxnDeltaG;NaN];
0748     <span class="keyword">end</span>
0749 <span class="keyword">end</span>
0750 
0751 <span class="comment">%Then remove all reactions and metabolites that aren't used in the final</span>
0752 <span class="comment">%solution from the optimization</span>
0753 [~, J]=find(bestS(:,1:nER+nComps*nRxns));
0754 K=true(numel(outModel.rxns),1);
0755 K(J)=false;
0756 K(end-nTransRxns+1:end)=false;
0757 outModel=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(outModel,K,true);
0758 
0759 <span class="comment">%Remove all fake genes</span>
0760 I=strncmp(<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span>,outModel.genes,8);
0761 outModel.genes(I)=[];
0762 <span class="keyword">if</span> isfield(outModel,<span class="string">'geneMiriams'</span>)
0763     outModel.geneMiriams(I)=[];
0764 <span class="keyword">end</span>
0765 <span class="keyword">if</span> isfield(outModel,<span class="string">'geneShortNames'</span>)
0766     outModel.geneShortNames(I)=[];
0767 <span class="keyword">end</span>
0768 <span class="keyword">if</span> isfield(outModel,<span class="string">'proteinNames'</span>)
0769     outModel.proteinNames(I)=[];
0770 <span class="keyword">end</span>
0771 outModel.rxnGeneMat(:,I)=[];
0772 
0773 <span class="comment">%Fix grRules and reconstruct rxnGeneMat</span>
0774 [grRules,rxnGeneMat] = <a href="standardizeGrRules.html" class="code" title="function [grRules,rxnGeneMat,indexes2check] = standardizeGrRules(model,embedded)">standardizeGrRules</a>(outModel,true);
0775 outModel.grRules = grRules;
0776 outModel.rxnGeneMat = rxnGeneMat;
0777 <span class="keyword">end</span>
0778 
0779 <span class="comment">%Moves a gene and all associated reactions from one compartment to another</span>
0780 <a name="_sub1" href="#_subfunctions" class="code">function [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)</a>
0781 <span class="comment">%Find the current compartment and update to the new one</span>
0782 currentComp=find(g2c(geneToMove,:));
0783 g2c(geneToMove,:)=false;
0784 g2c(geneToMove,toComp)=true;
0785 
0786 <span class="comment">%Find the reactions in the original model that the gene controls</span>
0787 [I, ~]=find(model.rxnGeneMat(:,geneToMove));
0788 
0789 <span class="comment">%Calculate their current positions in the S matrix</span>
0790 oldRxns=I+(currentComp-1)*nRxns;
0791 
0792 <span class="comment">%And their new positions</span>
0793 newRxns=I+(toComp-1)*nRxns;
0794 
0795 <span class="comment">%The metabolite ids also have to be changed in order to match the new</span>
0796 <span class="comment">%compartment</span>
0797 metChange=nMets*(toComp-currentComp);
0798 
0799 <span class="comment">%Update the reactions</span>
0800 [I, J, K]=find(S(:,oldRxns));
0801 I=I+metChange;
0802 
0803 <span class="comment">%Move the reactions</span>
0804 S(:,oldRxns)=0;
0805 S(sub2ind(size(S),I,newRxns(J)))=K;
0806 <span class="keyword">end</span>
0807 
0808 <span class="comment">%Finds which metabolites are unconnected, in the sense that they are never</span>
0809 <span class="comment">%a product or only a product in a reversible reaction where one reactant is</span>
0810 <span class="comment">%only a product in the opposite direction of that reaction. This function</span>
0811 <span class="comment">%ignores exchange metabolites. Returns a vector of metabolite indexes.</span>
0812 <span class="comment">%metsToCheck is an array of metabolite indexes to check for connectivity.</span>
0813 <span class="comment">%If not supplied then all metabolites are checked</span>
0814 <a name="_sub2" href="#_subfunctions" class="code">function unconnected=findUnconnected(S,nEM,metsToCheck)</a>
0815 <span class="keyword">if</span> nargin&gt;2
0816     <span class="comment">%Do this by deleting everything from the network that is not in</span>
0817     <span class="comment">%metsToCheck and that is not exchange metabolites</span>
0818     I=false(size(S,1),1);
0819     I(1:nEM)=true;
0820     I(metsToCheck)=true;
0821     S=S(I,:);
0822 <span class="keyword">end</span>
0823 
0824 em=false(size(S,1),1);
0825 em(1:nEM)=true;
0826 
0827 <span class="comment">%Construct a matrix in which the reversible reactions are inverted</span>
0828 I=sum(S&gt;2,1) | sum(S&gt;2,1);
0829 revS=S;
0830 revS(:,I)=revS(:,I)*-1;
0831 
0832 <span class="comment">%First calculate the ones that are ok</span>
0833 <span class="comment">%Produced in 2 rxns, is exchange, is not used at all, is produced in</span>
0834 <span class="comment">%non-reversible, involved in more than 1 reversible reactions</span>
0835 connected=sum(S&gt;0,2)&gt;1 | em | sum(S~=0,2)==0 | sum(S(:,~I)&gt;0,2)&gt;0 | sum(S(:,I)~=0,2)&gt;1;
0836 
0837 <span class="comment">%Then get the ones that are unconnected because they are never produced</span>
0838 unconnected=sum(S&gt;0 | revS&gt;0,2)==0 &amp; connected==false;
0839 
0840 <span class="comment">%Then get the ones that are potentially unconnected</span>
0841 maybeUnconnected=~connected &amp; ~unconnected;
0842 <span class="comment">%maybeUnconnected=find(maybeUnconnectedS);</span>
0843 
0844 <span class="comment">%The metabolites in maybeUnconnected are involved in one reversible</span>
0845 <span class="comment">%reaction and not produced in any other reaction. This means that the</span>
0846 <span class="comment">%reactions which have at least one met in maybeUnconnected as reactant and</span>
0847 <span class="comment">%one as product are unconnected. The metabolites in maybeUnconnected that</span>
0848 <span class="comment">%are present in those reactions are then dead ends</span>
0849 deadRxns=any(S(maybeUnconnected,:)&gt;0) &amp; any(S(maybeUnconnected,:)&lt;0);
0850 
0851 <span class="comment">%Get the mets involved in any of those reactions</span>
0852 problematic=any(S(:,deadRxns)~=0,2);
0853 
0854 <span class="comment">%If any of these are in the maybeUnconnected list then the metabolite is</span>
0855 <span class="comment">%unconnected</span>
0856 unconnected(problematic &amp; maybeUnconnected)=true;
0857 
0858 <span class="comment">%Map back to metsToCheck</span>
0859 <span class="keyword">if</span> nargin&gt;2
0860     unconnected=metsToCheck(unconnected(nEM+1:end));
0861 <span class="keyword">else</span>
0862     unconnected=find(unconnected);
0863 <span class="keyword">end</span>
0864 <span class="keyword">end</span>
0865 
0866 <span class="comment">%Given a set of unconnected metabolites, this function tries to move each</span>
0867 <span class="comment">%gene that could connect any of them, calculates the number of newly</span>
0868 <span class="comment">%connected metabolites minus the number of newly disconnected metabolites.</span>
0869 <span class="comment">%As some metabolites are very connected, only 25 genes are checked. Genes</span>
0870 <span class="comment">%that have a low score in their current compartment are more likely to be</span>
0871 <span class="comment">%moved</span>
0872 <a name="_sub3" href="#_subfunctions" class="code">function [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)</a>
0873 <span class="comment">%If moveTo is 0 then the gene cannot connect any of the metabolites</span>
0874 moveTo=zeros(numel(model.genes),1);
0875 deltaConnected=zeros(numel(model.genes),1);
0876 
0877 <span class="comment">%First get where the metabolites are now</span>
0878 nComps=size(g2c,2);
0879 comps=ceil((unconnected-nEM)/((size(S,1)-nEM)/nComps));
0880 
0881 <span class="comment">%Find the corresponding metabolite indexes if they all were in the default</span>
0882 <span class="comment">%compartment</span>
0883 dcIndexes=unique(unconnected-(comps-1)*nMets);
0884 
0885 <span class="comment">%Then find them if they were in any other compartment</span>
0886 allIndexes=dcIndexes;
0887 <span class="keyword">for</span> i=1:nComps-1
0888     allIndexes=[allIndexes;dcIndexes+nMets*i];
0889 <span class="keyword">end</span>
0890 
0891 <span class="comment">%Also check which reversible reactions that could be used</span>
0892 I=sum(S&gt;2,1) | sum(S&gt;2,1);
0893 revS=S;
0894 revS(:,I)=revS(:,I)*-1;
0895 
0896 <span class="comment">%Find all reactions that could make any of the unconnected metabolites in</span>
0897 <span class="comment">%some other compartment</span>
0898 newMets=setdiff(allIndexes,unconnected);
0899 [~, potential]=find(S(newMets,:)&gt;0 | revS(newMets,:)&gt;0);
0900 potential(potential&lt;=nER | potential&gt;nER+nRxns*nComps)=[]; <span class="comment">%No exchange rxns or transport rxns</span>
0901 
0902 <span class="comment">%Map J to the real metabolic reactions in model</span>
0903 rxnComps=ceil((potential-nER)/(nRxns));
0904 
0905 <span class="comment">%Find the corresponding reaction indexes if they all were in the default</span>
0906 <span class="comment">%compartment</span>
0907 dcRxnIndexes=potential-(rxnComps-1)*nRxns;
0908 
0909 <span class="comment">%Get the genes for those reactions</span>
0910 genes=find(sum(model.rxnGeneMat(dcRxnIndexes,:)&gt;0,1));
0911 
0912 <span class="comment">%For some cases there can be very many reactions to connect something. This</span>
0913 <span class="comment">%is in particular true in the beginning of the optimization if, say, ATP is</span>
0914 <span class="comment">%unconnected. Therefore limit the number of genes to be checked to 25.</span>
0915 <span class="comment">%Weigh so that genes with bad scores in their current compartment are more</span>
0916 <span class="comment">%likely to be moved.</span>
0917 
0918 <span class="comment">%Get scores for these genes</span>
0919 [~, J]=find(g2c(genes,:));
0920 
0921 <span class="comment">%Add a small weight so that genes in their best compartment could be moved</span>
0922 <span class="comment">%as well</span>
0923 geneScores=GSS.scores(sub2ind(size(g2c),genes(:),J));
0924 modGeneScores=1.1-geneScores;
0925 <span class="keyword">if</span> numel(genes)&gt;25
0926     rGenes=genes(<a href="#_sub6" class="code" title="subfunction y = randsample(n, k, replace, w)">randsample</a>(numel(genes),min(numel(genes),25),true,modGeneScores));
0927     
0928     <span class="comment">%The sampling with weights could give duplicates</span>
0929     rGenes=unique(rGenes);
0930     
0931     <span class="comment">%Reorder the geneScores to match</span>
0932     [~, I]=ismember(rGenes,genes);
0933     geneScores=geneScores(I);
0934     genes=rGenes;
0935 <span class="keyword">end</span>
0936 <span class="keyword">for</span> i=1:numel(genes)
0937     <span class="comment">%Since one gene is moved at a time, only metabolites involved in any of</span>
0938     <span class="comment">%the reactions for that gene can become unconnected. This helps to</span>
0939     <span class="comment">%speed up the algorithm. First get all involved reactions in the</span>
0940     <span class="comment">%default compartment</span>
0941     rxns=find(model.rxnGeneMat(:,genes(i)));
0942     
0943     <span class="comment">%Then get their mets</span>
0944     mets=find(sum(model.S(:,rxns)~=0,2)&gt;0);
0945     
0946     <span class="comment">%Then get their indexes in all compartments</span>
0947     allIndexes=mets;
0948     <span class="keyword">for</span> j=1:nComps-1
0949         allIndexes=[allIndexes;mets+nMets*j];
0950     <span class="keyword">end</span>
0951     
0952     <span class="comment">%Check which of the unconnected metabolites that these reactions</span>
0953     <span class="comment">%correspond to. This could have been done earlier, but it is fast. The</span>
0954     <span class="comment">%reversibility check is skipped because it is unlikely to be an issue</span>
0955     <span class="comment">%here. Worst case is that the gene is tested once to much</span>
0956     [I, ~]=find(model.S(:,rxns));
0957     moveToComps=unique(comps(ismember(dcIndexes,I)));
0958     
0959     <span class="comment">%Try to move the gene to each of the compartments</span>
0960     bestMove=-inf;
0961     bestComp=[];
0962     <span class="keyword">for</span> j=1:numel(moveToComps)
0963         newS=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(S,model,g2c,genes(i),moveToComps(j),nRxns,nMets);
0964         
0965         <span class="comment">%Check how many metabolites that are unconnected after moving the</span>
0966         <span class="comment">%gene</span>
0967         dConnected=numel(unconnected)-numel(<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS,nEM,[allIndexes;unconnected]));
0968         <span class="keyword">if</span> dConnected&gt;bestMove
0969             bestMove=dConnected;
0970             bestComp=moveToComps(j);
0971         <span class="keyword">end</span>
0972     <span class="keyword">end</span>
0973     
0974     <span class="comment">%Add the difference in connectivity and where the genes should be moved</span>
0975     moveTo(genes(i))=bestComp;
0976     deltaConnected(genes(i))=bestMove;
0977 <span class="keyword">end</span>
0978 
0979 <span class="comment">%Finish up</span>
0980 geneIndex=genes(:);
0981 moveTo=moveTo(geneIndex);
0982 deltaConnected=deltaConnected(geneIndex);
0983 deltaScore=GSS.scores(sub2ind(size(g2c),geneIndex(:),moveTo))-geneScores;
0984 <span class="keyword">end</span>
0985 
0986 <span class="comment">%Small function to add a transport reactions between two metabolites.</span>
0987 <span class="comment">%Transport reactions are written as having a coefficient 2.0 for both</span>
0988 <span class="comment">%reactant and product. This is not a &quot;real&quot; reaction, but since all normal</span>
0989 <span class="comment">%reactions have coefficient -1/1 or -10/10 it is a compact way of writing</span>
0990 <span class="comment">%it</span>
0991 <a name="_sub4" href="#_subfunctions" class="code">function S=addTransport(S,nRxns,nER,nMets,nEM,nComps,metA,metB)</a>
0992 mets=[metA;metB];
0993 <span class="comment">%Find the current compartments for the metabolites</span>
0994 comps=ceil((mets-nEM)/((size(S,1)-nEM)/nComps));
0995 
0996 <span class="keyword">if</span> sum(comps==1)~=1
0997     EM=<span class="string">'Tried to create a transport reaction from a non-default compartment'</span>;
0998     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM);
0999 <span class="keyword">end</span>
1000 
1001 <span class="comment">%Calculate the reaction index</span>
1002 rIndex=(nER+nRxns*nComps)+mets(comps~=1)-nEM-nMets;
1003 
1004 S(mets,rIndex)=2;
1005 <span class="keyword">end</span>
1006 
1007 <span class="comment">%Scores a network based on the localization of the genes and the number of</span>
1008 <span class="comment">%transporter reactions used</span>
1009 <a name="_sub5" href="#_subfunctions" class="code">function [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)</a>
1010 [I, J]=find(g2c);
1011 geneScore=sum(GSS.scores(sub2ind(size(g2c),I,J)));
1012 [I, ~]=find(S==2);
1013 I=unique(I);
1014 transportCost=sum(transportCost(I));
1015 score=geneScore-transportCost;
1016 <span class="keyword">end</span>
1017 
1018 <span class="comment">% To avoid dependency on stats toolbox, use this alternative implementation</span>
1019 <span class="comment">% of randsample, source:</span>
1020 <span class="comment">% https://github.com/gpeyre/numerical-tours/blob/dacee30081c04ef5f67b26b387ead85f2b193af9/matlab/toolbox_signal/randsample.m</span>
1021 <a name="_sub6" href="#_subfunctions" class="code">function y = randsample(n, k, replace, w)</a>
1022 <span class="comment">%RANDSAMPLE Random sample, with or without replacement.</span>
1023 <span class="comment">%   Y = RANDSAMPLE(N,K) returns Y as a vector of K values sampled uniformly</span>
1024 <span class="comment">%   at random, without replacement, from the integers 1:N.</span>
1025 <span class="comment">%</span>
1026 <span class="comment">%   Y = RANDSAMPLE(POPULATION,K) returns K values sampled uniformly at</span>
1027 <span class="comment">%   random, without replacement, from the values in the vector POPULATION.</span>
1028 <span class="comment">%</span>
1029 <span class="comment">%   Y = RANDSAMPLE(...,REPLACE) returns a sample taken with replacement if</span>
1030 <span class="comment">%   REPLACE is true, or without replacement if REPLACE is false (the default).</span>
1031 <span class="comment">%</span>
1032 <span class="comment">%   Y = RANDSAMPLE(...,true,W) returns a weighted sample, using positive</span>
1033 <span class="comment">%   weights W, taken with replacement.  W is often a vector of probabilities.</span>
1034 <span class="comment">%   This function does not support weighted sampling without replacement.</span>
1035 <span class="comment">%</span>
1036 <span class="comment">%   Example:  Generate a random sequence of the characters ACGT, with</span>
1037 <span class="comment">%   replacement, according to specified probabilities.</span>
1038 <span class="comment">%</span>
1039 <span class="comment">%      R = randsample('ACGT',48,true,[0.15 0.35 0.35 0.15])</span>
1040 <span class="comment">%</span>
1041 <span class="comment">%   See also RAND, RANDPERM.</span>
1042 
1043 <span class="comment">%   Copyright 1993-2008 The MathWorks, Inc.</span>
1044 <span class="comment">%   $Revision: 1.1.4.3 $  $Date: 2008/12/01 08:09:34 $</span>
1045 
1046 <span class="keyword">if</span> nargin &lt; 2
1047     error(<span class="string">'stats:randsample:TooFewInputs'</span>,<span class="string">'Requires two input arguments.'</span>);
1048 <span class="keyword">elseif</span> numel(n) == 1
1049     population = [];
1050 <span class="keyword">else</span>
1051     population = n;
1052     n = numel(population);
1053     <span class="keyword">if</span> length(population)~=n
1054        error(<span class="string">'stats:randsample:BadPopulation'</span>,<span class="string">'POPULATION must be a vector.'</span>);
1055     <span class="keyword">end</span>
1056 <span class="keyword">end</span>
1057 
1058 <span class="keyword">if</span> nargin &lt; 3
1059     replace = false;
1060 <span class="keyword">end</span>
1061 
1062 <span class="keyword">if</span> nargin &lt; 4
1063     w = [];
1064 <span class="keyword">elseif</span> ~isempty(w)
1065     <span class="keyword">if</span> length(w) ~= n
1066         <span class="keyword">if</span> isempty(population)
1067             error(<span class="string">'stats:randsample:InputSizeMismatch'</span>,<span class="keyword">...</span>
1068                   <span class="string">'W must have length equal to N.'</span>);
1069         <span class="keyword">else</span>
1070             error(<span class="string">'stats:randsample:InputSizeMismatch'</span>,<span class="keyword">...</span>
1071                   <span class="string">'W must have the same length as the population.'</span>);
1072         <span class="keyword">end</span>
1073     <span class="keyword">else</span>
1074         p = w(:)' / sum(w);
1075     <span class="keyword">end</span>
1076 <span class="keyword">end</span>
1077 
1078 <span class="keyword">switch</span> replace
1079 
1080 <span class="comment">% Sample with replacement</span>
1081 <span class="keyword">case</span> {true, <span class="string">'true'</span>, 1}
1082     <span class="keyword">if</span> isempty(w)
1083         y = ceil(n .* rand(k,1));
1084     <span class="keyword">else</span>
1085         [dum, y] = histc(rand(k,1),[0 cumsum(p)]);
1086     <span class="keyword">end</span>
1087 
1088 <span class="comment">% Sample without replacement</span>
1089 <span class="keyword">case</span> {false, <span class="string">'false'</span>, 0}
1090     <span class="keyword">if</span> k &gt; n
1091         <span class="keyword">if</span> isempty(population)
1092             error(<span class="string">'stats:randsample:SampleTooLarge'</span>,<span class="keyword">...</span>
1093         <span class="string">'K must be less than or equal to N for sampling without replacement.'</span>);
1094         <span class="keyword">else</span>
1095             error(<span class="string">'stats:randsample:SampleTooLarge'</span>,<span class="keyword">...</span>
1096                   <span class="string">'K must be less than or equal to the population size.'</span>);
1097         <span class="keyword">end</span>
1098     <span class="keyword">end</span>
1099 
1100     <span class="keyword">if</span> isempty(w)
1101         <span class="comment">% If the sample is a sizeable fraction of the population,</span>
1102         <span class="comment">% just randomize the whole population (which involves a full</span>
1103         <span class="comment">% sort of n random values), and take the first k.</span>
1104         <span class="keyword">if</span> 4*k &gt; n
1105             rp = randperm(n);
1106             y = rp(1:k);
1107 
1108         <span class="comment">% If the sample is a small fraction of the population, a full sort</span>
1109         <span class="comment">% is wasteful.  Repeatedly sample with replacement until there are</span>
1110         <span class="comment">% k unique values.</span>
1111         <span class="keyword">else</span>
1112             x = zeros(1,n); <span class="comment">% flags</span>
1113             sumx = 0;
1114             <span class="keyword">while</span> sumx &lt; k
1115                 x(ceil(n * rand(1,k-sumx))) = 1; <span class="comment">% sample w/replacement</span>
1116                 sumx = sum(x); <span class="comment">% count how many unique elements so far</span>
1117             <span class="keyword">end</span>
1118             y = find(x &gt; 0);
1119             y = y(randperm(k));
1120         <span class="keyword">end</span>
1121     <span class="keyword">else</span>
1122         error(<span class="string">'stats:randsample:NoWeighting'</span>,<span class="keyword">...</span>
1123               <span class="string">'Weighted sampling without replacement is not supported.'</span>);
1124     <span class="keyword">end</span>
1125 <span class="keyword">otherwise</span>
1126     error(<span class="string">'stats:randsample:BadReplaceValue'</span>,<span class="keyword">...</span>
1127           <span class="string">'REPLACE must be either true or false.'</span>);
1128 <span class="keyword">end</span>
1129 
1130 <span class="keyword">if</span> ~isempty(population)
1131     y = population(y);
1132 <span class="keyword">else</span>
1133     y = y(:);
1134 <span class="keyword">end</span>
1135 <span class="keyword">end</span></pre></div>
<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>