<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of predictLocalization</title>
  <meta name="keywords" content="predictLocalization">
  <meta name="description" content="predictLocalization">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">core</a> &gt; predictLocalization.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for core&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>predictLocalization
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>predictLocalization</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [outModel, geneLocalization, transportStruct, scores, removedRxns]=predictLocalization(model,GSS,defaultCompartment,transportCost,maxTime,plotResults) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> predictLocalization
   Tries to assign reactions to compartments in a manner that is in
   agreement with localization predictors while at the same time
   maintaining connectivity.

   model                 a model structure. If the model contains several
                         compartments they will be merged
   GSS                   gene scoring structure as from parseScores
   defaultCompartment    transport reactions are expressed as diffusion
                         between the defaultCompartment and the others.
                         This is usually the cytosol. The default
                         compartment must have a match in
                         GSS
   transportCost         the cost for including a transport reaction. If this
                         a scalar then the same cost is used for all metabolites.
                         It can also be a vector of costs with the same dimension
                         as model.mets. Note that negative costs will result in that
                         transport of the metabolite is encouraged (opt, default 0.5)
   maxTime               maximum optimization time in minutes (opt,
                         default 15)
   plotResults           true if the result should be plotted during the
                         optimization (opt false)

   outModel              the resulting model structure
   geneLocalization      structure with the genes and their resulting
                         localization
   transportStruct       structure with the transport reactions that had
                         to be inferred and between which compartments
   scores                structure that contains the total score history
                         together with the score based on gene localization
                         and the score based on included transport reactions
   removedRxns           cell array with the reaction ids that had to be
                         removed in order to have a connected input model

   This function requires that the starting network is connected when it's in
   one compartment. Reactions that are unconnected are removed and saved
   in removedRxns. Try running fillGaps to have a more connected input
   model if there are many such reactions.

   In the final model all metabolites are produced in at least one reaction.
   This doesn't guarantee a fully functional model since there can be internal
   loops. Transport reactions are only included as passive diffusion (A &lt;=&gt; B).

   The score of a model is the sum of scores for all genes in their
   assigned compartment minus the cost of all transport reactions that
   had to be included. A gene can only be assigned to one compartment.
   This is a simplification to keep the problem size down. The problem is
   solved using simulated annealing.

   Usage: [outModel, geneLocalization, transportStruct, score, removedRxns]=...
       predictLocalization(model,GSS,defaultCompartment,transportCost,maxTime)

   Simonas Marcisauskas, 2017-09-06</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting)">addTransport</a>	addTransport</li><li><a href="convertToIrrev.html" class="code" title="function irrevModel=convertToIrrev(model,rxns)">convertToIrrev</a>	convertToIrrev</li><li><a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>	dispEM</li><li><a href="expandModel.html" class="code" title="function newModel=expandModel(model)">expandModel</a>	expandModel</li><li><a href="getExchangeRxns.html" class="code" title="function [exchangeRxns, exchangeRxnsIndexes]=getExchangeRxns(model,reactionType)">getExchangeRxns</a>	getExchangeRxns</li><li><a href="mergeCompartments.html" class="code" title="function [model, deletedRxns, duplicateRxns]=mergeCompartments(model,keepUnconstrained,deleteRxnsWithOneMet,distReverse)">mergeCompartments</a>	mergeCompartments</li><li><a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>	permuteModel</li><li><a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>	removeReactions</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)</a></li><li><a href="#_sub2" class="code">function unconnected=findUnconnected(S,nEM,metsToCheck)</a></li><li><a href="#_sub3" class="code">function [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)</a></li><li><a href="#_sub4" class="code">function S=addTransport(S,nRxns,nER,nMets,nEM,nComps,metA,metB)</a></li><li><a href="#_sub5" class="code">function [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [outModel, geneLocalization, transportStruct, scores, removedRxns]=predictLocalization(model,GSS,defaultCompartment,transportCost,maxTime,plotResults)</a>
0002 <span class="comment">% predictLocalization</span>
0003 <span class="comment">%   Tries to assign reactions to compartments in a manner that is in</span>
0004 <span class="comment">%   agreement with localization predictors while at the same time</span>
0005 <span class="comment">%   maintaining connectivity.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%   model                 a model structure. If the model contains several</span>
0008 <span class="comment">%                         compartments they will be merged</span>
0009 <span class="comment">%   GSS                   gene scoring structure as from parseScores</span>
0010 <span class="comment">%   defaultCompartment    transport reactions are expressed as diffusion</span>
0011 <span class="comment">%                         between the defaultCompartment and the others.</span>
0012 <span class="comment">%                         This is usually the cytosol. The default</span>
0013 <span class="comment">%                         compartment must have a match in</span>
0014 <span class="comment">%                         GSS</span>
0015 <span class="comment">%   transportCost         the cost for including a transport reaction. If this</span>
0016 <span class="comment">%                         a scalar then the same cost is used for all metabolites.</span>
0017 <span class="comment">%                         It can also be a vector of costs with the same dimension</span>
0018 <span class="comment">%                         as model.mets. Note that negative costs will result in that</span>
0019 <span class="comment">%                         transport of the metabolite is encouraged (opt, default 0.5)</span>
0020 <span class="comment">%   maxTime               maximum optimization time in minutes (opt,</span>
0021 <span class="comment">%                         default 15)</span>
0022 <span class="comment">%   plotResults           true if the result should be plotted during the</span>
0023 <span class="comment">%                         optimization (opt false)</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%   outModel              the resulting model structure</span>
0026 <span class="comment">%   geneLocalization      structure with the genes and their resulting</span>
0027 <span class="comment">%                         localization</span>
0028 <span class="comment">%   transportStruct       structure with the transport reactions that had</span>
0029 <span class="comment">%                         to be inferred and between which compartments</span>
0030 <span class="comment">%   scores                structure that contains the total score history</span>
0031 <span class="comment">%                         together with the score based on gene localization</span>
0032 <span class="comment">%                         and the score based on included transport reactions</span>
0033 <span class="comment">%   removedRxns           cell array with the reaction ids that had to be</span>
0034 <span class="comment">%                         removed in order to have a connected input model</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%   This function requires that the starting network is connected when it's in</span>
0037 <span class="comment">%   one compartment. Reactions that are unconnected are removed and saved</span>
0038 <span class="comment">%   in removedRxns. Try running fillGaps to have a more connected input</span>
0039 <span class="comment">%   model if there are many such reactions.</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%   In the final model all metabolites are produced in at least one reaction.</span>
0042 <span class="comment">%   This doesn't guarantee a fully functional model since there can be internal</span>
0043 <span class="comment">%   loops. Transport reactions are only included as passive diffusion (A &lt;=&gt; B).</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%   The score of a model is the sum of scores for all genes in their</span>
0046 <span class="comment">%   assigned compartment minus the cost of all transport reactions that</span>
0047 <span class="comment">%   had to be included. A gene can only be assigned to one compartment.</span>
0048 <span class="comment">%   This is a simplification to keep the problem size down. The problem is</span>
0049 <span class="comment">%   solved using simulated annealing.</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%   Usage: [outModel, geneLocalization, transportStruct, score, removedRxns]=...</span>
0052 <span class="comment">%       predictLocalization(model,GSS,defaultCompartment,transportCost,maxTime)</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%   Simonas Marcisauskas, 2017-09-06</span>
0055 <span class="comment">%</span>
0056 
0057 <span class="keyword">if</span> nargin&lt;4
0058     transportCost=ones(numel(model.mets),1)*0.5;
0059 <span class="keyword">end</span>
0060 <span class="keyword">if</span> numel(transportCost)==1
0061     transportCost=ones(numel(model.mets),1)*transportCost;
0062 <span class="keyword">end</span>
0063 transportCost=transportCost(:);
0064 
0065 <span class="keyword">if</span> numel(transportCost)~=numel(model.mets)
0066     EM=<span class="string">'The vector of transport costs must have the same dimension as model.mets'</span>;
0067     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,true);
0068 <span class="keyword">end</span>
0069 <span class="keyword">if</span> nargin&lt;5
0070     maxTime=15;
0071 <span class="keyword">end</span>
0072 <span class="keyword">if</span> nargin&lt;6
0073     plotResults=false;
0074 <span class="keyword">end</span>
0075 
0076 <span class="keyword">if</span> isfield(model,<span class="string">'rxnComps'</span>)
0077    model=rmfield(model,<span class="string">'rxnComps'</span>);
0078    EM=<span class="string">'The model structure contains information about reaction compartmentalization. This is not supported by this function. The rxnComps field has been deleted'</span>;
0079    <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0080 <span class="keyword">end</span>
0081 <span class="keyword">if</span> isfield(model,<span class="string">'geneComps'</span>)
0082    model=rmfield(model,<span class="string">'geneComps'</span>);
0083    EM=<span class="string">'The model structure contains information about gene compartmentalization. This is not supported by this function. The geneComps field has been deleted'</span>;
0084    <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0085 <span class="keyword">end</span>
0086 
0087 I=ismember(defaultCompartment,GSS.compartments);
0088 <span class="keyword">if</span> I==false
0089     EM=<span class="string">'defaultCompartment not found in GSS'</span>;
0090     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM);
0091 <span class="keyword">end</span>
0092 
0093 <span class="keyword">if</span> numel(model.comps)&gt;1
0094     EM=<span class="string">'The model has several compartments. All compartments will be merged'</span>;
0095     <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0096     model=<a href="mergeCompartments.html" class="code" title="function [model, deletedRxns, duplicateRxns]=mergeCompartments(model,keepUnconstrained,deleteRxnsWithOneMet,distReverse)">mergeCompartments</a>(model,true,true);
0097 <span class="keyword">end</span>
0098 
0099 <span class="comment">%***Begin formating the data structures</span>
0100 
0101 <span class="comment">%Expand the model so that iso-enzymes have different reactions</span>
0102 model=<a href="expandModel.html" class="code" title="function newModel=expandModel(model)">expandModel</a>(model);
0103 
0104 <span class="comment">%Identify reactions that have to be deleted because the involved mets are</span>
0105 <span class="comment">%never produced. This is done in an iterative manner</span>
0106 removedRxns={};
0107 <span class="comment">%This is to keep track of which metabolites are removed in this step. It is</span>
0108 <span class="comment">%needed to adjust the transport costs</span>
0109 originalModelMets=model.mets;
0110 <span class="keyword">while</span> 1
0111     irrevModel=<a href="convertToIrrev.html" class="code" title="function irrevModel=convertToIrrev(model,rxns)">convertToIrrev</a>(model);
0112 
0113     I=sum(irrevModel.S&gt;0,2);
0114 
0115     <span class="comment">%Pretend that the unconstrained metabolites are made enough</span>
0116     <span class="keyword">if</span> isfield(irrevModel,<span class="string">'unconstrained'</span>)
0117         I(irrevModel.unconstrained~=0)=2;
0118     <span class="keyword">end</span>
0119     metsToDelete=false(numel(model.mets),1);
0120 
0121     <span class="comment">%This is not very neat but I loop through each metabolite and check whether</span>
0122     <span class="comment">%it can be produced (without using only one isolated reversible reaction)</span>
0123     <span class="keyword">for</span> i=1:numel(irrevModel.mets)
0124         <span class="comment">%If something can be made in two reactions then everything is fine. If i</span>
0125         <span class="comment">%can be made in one reaction it's fine unless it's through an isolated</span>
0126         <span class="comment">%reversible reaction (which can act as a mini loop)</span>
0127         <span class="keyword">if</span> I(i)&lt;2
0128             <span class="keyword">if</span> I(i)==1
0129                 <span class="comment">%Find the reaction where this metabolite is produced</span>
0130                 [~, J]=find(irrevModel.S(i,:)&gt;0);
0131 
0132                 <span class="comment">%Check the metabolites that are consumed in this reaction. The</span>
0133                 <span class="comment">%problem is if any of them is only produced in the opposite</span>
0134                 <span class="comment">%reversible reaction</span>
0135                 K=irrevModel.S(:,J)&lt;0;
0136                 check=find(K &amp; I&lt;=1);
0137 
0138                 <span class="keyword">for</span> j=1:numel(check)
0139                     <span class="comment">%Find the reactions where it participates</span>
0140                     [~, L]=find(irrevModel.S(check(j),:)&gt;0);
0141 
0142                     <span class="keyword">if</span> ~isempty(L)
0143                         rxn=irrevModel.rxns(J);
0144                         rxnRev=irrevModel.rxns(L);
0145                         <span class="keyword">if</span> strcmp(strrep(rxn,<span class="string">'_REV'</span>,<span class="string">''</span>),strrep(rxnRev,<span class="string">'_REV'</span>,<span class="string">''</span>))
0146                            metsToDelete(i)=true;
0147                         <span class="keyword">end</span>
0148                     <span class="keyword">else</span>
0149                         <span class="comment">%If the metabolite was never produced then do nothing and deal with</span>
0150                         <span class="comment">%it when the loop gets there :)</span>
0151                         <span class="keyword">continue</span>;
0152                     <span class="keyword">end</span>
0153                 <span class="keyword">end</span>
0154             <span class="keyword">else</span>
0155                 <span class="comment">%Not made anywhere</span>
0156                 metsToDelete(i)=true;
0157             <span class="keyword">end</span>
0158         <span class="keyword">end</span>
0159     <span class="keyword">end</span>
0160 
0161     <span class="keyword">if</span> any(metsToDelete)
0162         <span class="comment">%Delete any reactions involving any of the metsToDelete</span>
0163         [~, I]=find(model.S(metsToDelete,:));
0164         removedRxns=[removedRxns;model.rxns(I)];
0165         model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,I,true,true);
0166     <span class="keyword">else</span>
0167         <span class="comment">%All bad reactions deleted</span>
0168         <span class="keyword">break</span>;
0169     <span class="keyword">end</span>
0170 <span class="keyword">end</span>
0171 
0172 <span class="comment">%Adjust the transport costs</span>
0173 transportCost=transportCost(ismember(originalModelMets,model.mets));
0174 
0175 <span class="comment">%Assign fake genes to reactions without genes. This is just to make things</span>
0176 <span class="comment">%easier later on</span>
0177 I=find(sum(model.rxnGeneMat,2)==0);
0178 <span class="keyword">for</span> i=1:numel(I)
0179     model.genes=[model.genes;[<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span> num2str(i)]];
0180     <span class="keyword">if</span> isfield(model,<span class="string">'geneShortNames'</span>)
0181         model.geneShortNames=[model.geneShortNames;{<span class="string">''</span>}];
0182     <span class="keyword">end</span>
0183     <span class="keyword">if</span> isfield(model,<span class="string">'geneMiriams'</span>)
0184         model.geneMiriams=[model.geneMiriams;{[]}];
0185     <span class="keyword">end</span>
0186     <span class="keyword">if</span> isfield(model,<span class="string">'geneFrom'</span>)
0187         model.geneFrom=[model.geneFrom;{{<span class="string">'FAKE'</span>}}];
0188     <span class="keyword">end</span>
0189     model.rxnGeneMat(I(i),numel(model.genes))=1;
0190     model.grRules{I(i)}=<span class="string">''</span>;
0191 <span class="keyword">end</span>
0192 
0193 <span class="comment">%Update the GSS. All genes, fake or real, for which</span>
0194 <span class="comment">%there is no evidence gets a score 0.5 in all compartments. Also just to</span>
0195 <span class="comment">%make it easier further on</span>
0196 I=setdiff(model.genes,GSS.genes);
0197 GSS.genes=[GSS.genes;I];
0198 GSS.scores=[GSS.scores;ones(numel(I),numel(GSS.compartments))*0.5];
0199 
0200 <span class="comment">%Gene complexes should be moved together in order to be biologically</span>
0201 <span class="comment">%relevant. The average score for the genes is used for each compartment.</span>
0202 <span class="comment">%This is done by changing the model so that gene complexes are used as a</span>
0203 <span class="comment">%single gene name and then a score is calculated for that &quot;gene&quot;.</span>
0204 
0205 <span class="comment">%Only &quot;and&quot;-relationships exist after expandModel</span>
0206 genes=unique(model.grRules);
0207 nGenes=strrep(genes,<span class="string">'('</span>,<span class="string">''</span>);
0208 nGenes=strrep(nGenes,<span class="string">')'</span>,<span class="string">''</span>);
0209 <span class="comment">%nGenes=strrep(nGenes,' and ','_and_');</span>
0210 complexes=setdiff(nGenes,model.genes);
0211 <span class="keyword">if</span> ~isempty(complexes)
0212     <span class="keyword">if</span> isempty(complexes{1}) <span class="comment">%Empty grRules also come up here</span>
0213         complexes(1)=[];
0214     <span class="keyword">end</span>
0215 <span class="keyword">end</span>
0216 cScores=zeros(numel(complexes),numel(GSS.compartments));
0217 <span class="keyword">for</span> i=1:numel(complexes)
0218     genesInComplex=regexp(complexes{i},<span class="string">' and '</span>,<span class="string">'split'</span>);
0219 
0220     <span class="comment">%Find these genes in GSS</span>
0221     [I, J]=ismember(genesInComplex,GSS.genes);
0222 
0223     <span class="keyword">if</span> any(I)
0224         <span class="comment">%Get the average of the genes that were found.</span>
0225         mScores=mean(GSS.scores(J(I),:));
0226 
0227         <span class="comment">%And add 0.5 for the genes that were not found in order to be</span>
0228         <span class="comment">%consistent with non-complexes</span>
0229         mScores=(mScores.*sum(I)+(numel(genesInComplex)-sum(I))*0.5)/numel(genesInComplex);
0230     <span class="keyword">else</span>
0231         EM=[<span class="string">'Could not parse grRule &quot;'</span> complexes{i} <span class="string">'&quot;. Assigning score 0.0 in all compartments'</span>];
0232         <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM,false);
0233         mScores=ones(1,numel(genesInComplex))*0.5;
0234     <span class="keyword">end</span>
0235     cScores(i,:)=mScores;
0236 
0237     <span class="comment">%Add this complex as a new gene</span>
0238     model.genes=[model.genes;complexes{i}];
0239     <span class="keyword">if</span> isfield(model,<span class="string">'geneMiriams'</span>)
0240         model.geneMiriams=[model.geneMiriams;{[]}];
0241     <span class="keyword">end</span>
0242     <span class="keyword">if</span> isfield(model,<span class="string">'geneShortNames'</span>)
0243         model.geneShortNames=[model.geneShortNames;{<span class="string">''</span>}];
0244     <span class="keyword">end</span>
0245     <span class="keyword">if</span> isfield(model,<span class="string">'geneFrom'</span>)
0246         model.geneFrom=[model.geneFrom;{<span class="string">'COMPLEX'</span>}];
0247     <span class="keyword">end</span>
0248     <span class="comment">%Find the reactions which had the original complex and change them to</span>
0249     <span class="comment">%use the new &quot;gene&quot;</span>
0250     I=ismember(model.grRules,[<span class="string">'('</span> complexes{i} <span class="string">')'</span>]);
0251 
0252     <span class="comment">%Should check more carefully if there can be an error here</span>
0253     <span class="keyword">if</span> ~isempty(I)
0254         model.rxnGeneMat(I,:)=0; <span class="comment">%Ok since we have split on &quot;or&quot;</span>
0255         model.rxnGeneMat(I,numel(model.genes))=1;
0256     <span class="keyword">end</span>
0257 <span class="keyword">end</span>
0258 
0259 <span class="comment">%Add the new &quot;genes&quot;</span>
0260 GSS.genes=[GSS.genes;complexes];
0261 GSS.scores=[GSS.scores;cScores];
0262 
0263 <span class="comment">%After merging the complexes it could happen that there are genes that are</span>
0264 <span class="comment">%no longer in use. Delete such genes</span>
0265 model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,{},false,true);
0266 
0267 <span class="comment">%Exchange reactions, defined as involving an unconstrained metabolite, are</span>
0268 <span class="comment">%special in that they have to stay in the defaultCompartment. This means</span>
0269 <span class="comment">%that uptake/excretion of metabolites is always via the default</span>
0270 <span class="comment">%compartment. This is a small simplification, but should be valid in most</span>
0271 <span class="comment">%cases</span>
0272 [~, I]=<a href="getExchangeRxns.html" class="code" title="function [exchangeRxns, exchangeRxnsIndexes]=getExchangeRxns(model,reactionType)">getExchangeRxns</a>(model);
0273 
0274 <span class="comment">%It will be easier later on if the same place. Put them in the beginning</span>
0275 J=1:numel(model.rxns);
0276 J(I)=[];
0277 model=<a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>(model,[I;J'],<span class="string">'rxns'</span>);
0278 
0279 <span class="comment">%Number of exchange reactions</span>
0280 nER=numel(I);
0281 
0282 <span class="comment">%Also put the exchange metabolites in the beginning</span>
0283 <span class="keyword">if</span> isfield(model,<span class="string">'unconstrained'</span>)
0284     I=find(model.unconstrained);
0285     J=1:numel(model.mets);
0286     J(I)=[];
0287     model=<a href="permuteModel.html" class="code" title="function newModel=permuteModel(model, indexes, type)">permuteModel</a>(model,[I;J'],<span class="string">'mets'</span>);
0288     <span class="comment">%Also reorder the transport costs</span>
0289     transportCost=transportCost([I;J']);
0290     <span class="comment">%Number of exchange metabolites</span>
0291     nEM=numel(I);
0292 <span class="keyword">else</span>
0293     nEM=0;
0294 <span class="keyword">end</span>
0295 
0296 <span class="comment">%There is no point of having genes for exchange reactions, so delete them.</span>
0297 <span class="comment">%Also to make computations easier.</span>
0298 model.rxnGeneMat(1:nER,:)=0;
0299 model.grRules(1:nER)={<span class="string">''</span>};
0300 
0301 <span class="comment">%Remove unused genes</span>
0302 model=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(model,{},false,true);
0303 
0304 <span class="comment">%Remove genes with no match to the model and reorder so that the genes are</span>
0305 <span class="comment">%in the same order as model.genes. Since we have already added fake genes</span>
0306 <span class="comment">%so that all genes in model exist in GSS it's fine to do</span>
0307 <span class="comment">%like this.</span>
0308 [~, J]=ismember(model.genes,GSS.genes);
0309 GSS.genes=model.genes;
0310 GSS.scores=GSS.scores(J,:);
0311 
0312 <span class="comment">%Reorder the GSS so that the first index corresponds to the</span>
0313 <span class="comment">%default compartment</span>
0314 [~, J]=ismember(defaultCompartment,GSS.compartments);
0315 reorder=1:numel(GSS.compartments);
0316 reorder(J)=[];
0317 reorder=[J reorder];
0318 GSS.scores=GSS.scores(:,reorder);
0319 GSS.compartments=GSS.compartments(reorder);
0320 
0321 <span class="comment">%Since we're only looking at whether the metabolites can be synthesized, we</span>
0322 <span class="comment">%don't have to care about the stoichiometry. Change to -1/1 to simplify</span>
0323 <span class="comment">%later. Keep the S matrix for later though.</span>
0324 oldS=model.S;
0325 model.S(model.S&gt;0)=1;
0326 model.S(model.S&lt;0)=-1;
0327 
0328 <span class="comment">%Here I do a bit of a trick. Since I don't want to calculate which</span>
0329 <span class="comment">%reactions are reversible all the time, I let reversible reactions have the</span>
0330 <span class="comment">%coefficients -10/10 instead of -1/1</span>
0331 model.S(:,model.rev==1)=model.S(:,model.rev==1).*10;
0332 
0333 <span class="comment">%***Begin problem formulation</span>
0334 
0335 <span class="comment">%Some numbers that are good to have</span>
0336 nRxns=numel(model.rxns)-nER; <span class="comment">%Excluding exchange rxns</span>
0337 nMets=numel(model.mets)-nEM; <span class="comment">%Excluding exchange mets</span>
0338 nGenes=numel(model.genes);
0339 nComps=numel(GSS.compartments);
0340 
0341 <span class="comment">%Create a big stoichiometric matrix that will be the current model. In</span>
0342 <span class="comment">%order to have faster simulations the maximal model size is declared and</span>
0343 <span class="comment">%reactions are then moved within it.</span>
0344 
0345 <span class="comment">%First the original model (with the first nE being exchange rxns), then</span>
0346 <span class="comment">%reserve space for number of rxns minus exchange rxns for each non-default</span>
0347 <span class="comment">%compartment, then transport reactions for all non-exchange mets between</span>
0348 <span class="comment">%the default compartment and all others.</span>
0349 <span class="comment">%NOTE: Kept eye()*0 since eye() can be used to include all transport from</span>
0350 <span class="comment">%the beginning</span>
0351 s=repmat(eye(nMets)*0,1,nComps-1);
0352 s=[zeros(numel(model.mets)-nMets,size(s,2));s];
0353 S=[model.S sparse(numel(model.mets),nRxns*(nComps-1)) s];
0354 s=[sparse(nMets*(nComps-1),numel(model.rxns)+nRxns*(nComps-1)) eye(nMets*(nComps-1))*0];
0355 S=[S;s];
0356 
0357 <span class="comment">%Also replicate the transport costs</span>
0358 transportCost=[transportCost(1:nEM);repmat(transportCost(nEM+1:end),nComps,1)];
0359 
0360 <span class="comment">%Create a binary matrix that says where the genes are in the current</span>
0361 <span class="comment">%solution</span>
0362 g2c=false(nGenes,nComps);
0363 <span class="comment">%All genes start in the default compartment</span>
0364 g2c(:,1)=true;
0365 
0366 <span class="comment">%Start of main optimization loop</span>
0367 tic;
0368 bestScore=-inf;
0369 bestS=[];
0370 bestg2c=[];
0371 
0372 <span class="comment">%Temp for testing</span>
0373 plotScore=[];
0374 nTrans=[];
0375 totScore=[];
0376 minScore=sum(min(GSS.scores,[],2));
0377 maxScore=sum(max(GSS.scores,[],2));
0378 
0379 <span class="keyword">while</span> toc&lt;maxTime*60
0380    <span class="comment">%Pick a random gene, weighted by it's current score minus the best score</span>
0381    <span class="comment">%for that gene (often 1.0, but can be 0.5 for no genes or average for complexes.</span>
0382    <span class="comment">%Genes with bad fits are more likely to be moved. This formulation never</span>
0383    <span class="comment">%moves a gene from its best compartment. Therefore a small uniform</span>
0384    <span class="comment">%weight is added.</span>
0385    [I, J]=find(g2c);
0386    geneToMove=randsample(nGenes,1,true,max(GSS.scores(I,:),[],2)-GSS.scores(sub2ind(size(g2c),I,J))+0.1);
0387 
0388    <span class="comment">%Sample among possible compartments to move to. Add a larger weight to</span>
0389    <span class="comment">%even out the odds a little. Also a way of getting rid of loops where</span>
0390    <span class="comment">%the same set of genes are moved back and forth several times.</span>
0391    toComp=randsample(nComps,1,true,GSS.scores(geneToMove,:)+0.2);
0392 
0393    <span class="comment">%Check that it moves to a new compartment</span>
0394    <span class="keyword">if</span> toComp==find(g2c(geneToMove,:))
0395        <span class="keyword">continue</span>;
0396    <span class="keyword">end</span>
0397 
0398    <span class="comment">%Moves the gene</span>
0399    [newS, newg2c]=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(S,model,g2c,geneToMove,toComp,nRxns,nMets);
0400 
0401    <span class="comment">%Tries to connect the network. If this was not possible in 10</span>
0402    <span class="comment">%iterations, then abort. If more than 20 modifications were needed then</span>
0403    <span class="comment">%it's unlikely that it will be a lower score</span>
0404    wasConnected=false;
0405    <span class="keyword">for</span> j=1:10
0406        <span class="comment">%Find the metabolites that are now unconnected</span>
0407        unconnected=<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS,nEM);
0408 
0409        <span class="comment">%Continue if there are still unconnected</span>
0410        <span class="keyword">if</span> any(unconnected)
0411            <span class="comment">%For each gene find out how many of these could be connected if</span>
0412            <span class="comment">%the gene was moved and how many would be disconnected by moving</span>
0413            <span class="comment">%that gene</span>
0414            [geneIndex, moveTo, deltaConnected, deltaScore]=<a href="#_sub3" class="code" title="subfunction [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)">selectGenes</a>(newS,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS);
0415 
0416            <span class="comment">%Score which gene would be the best to move. The highest</span>
0417            <span class="comment">%deltaScore is 1.0. I want it to be possible to move a gene from</span>
0418            <span class="comment">%worst to best compartment even if it disconnects, say, 1.5 more</span>
0419            <span class="comment">%metabolites.</span>
0420            [score, I]=max(1.5*deltaScore+deltaConnected);
0421 
0422            <span class="comment">%Checks if it has to add a transport or if there is a gene that</span>
0423            <span class="comment">%could be moved order to have a more connected network</span>
0424            hasToAddTransport=true;
0425            <span class="keyword">if</span> ~isempty(deltaConnected)
0426               <span class="keyword">if</span> score&gt;0
0427                   hasToAddTransport=false;
0428               <span class="keyword">end</span>
0429            <span class="keyword">end</span>
0430 
0431            <span class="comment">%If it is possible to move any gene in order to have a more</span>
0432            <span class="comment">%connected network, then move the best one</span>
0433            <span class="keyword">if</span> hasToAddTransport==false;
0434                 [newS, newg2c]=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(newS,model,g2c,geneIndex(I),moveTo(I),nRxns,nMets);
0435            <span class="keyword">else</span>
0436                 <span class="comment">%Choose a random unconnected metabolite that should be</span>
0437                 <span class="comment">%connected</span>
0438                 transMet=unconnected(randsample(numel(unconnected),1));
0439 
0440                 <span class="comment">%First get where the metabolite is now</span>
0441                 comps=ceil((transMet-nEM)/((size(S,1)-nEM)/nComps));
0442 
0443                 <span class="comment">%Find the corresponding metabolite index if it were in the</span>
0444                 <span class="comment">%default compartment</span>
0445                 dcIndex=transMet-(comps-1)*nMets;
0446 
0447                 <span class="comment">%Then get the indexes of that metabolite in all</span>
0448                 <span class="comment">%compartments</span>
0449                 allIndexes=dcIndex;
0450                 <span class="keyword">for</span> k=1:nComps-1
0451                    allIndexes=[allIndexes;dcIndex+nMets*k];
0452                 <span class="keyword">end</span>
0453 
0454                 <span class="comment">%It could be that some of these aren't used in any</span>
0455                 <span class="comment">%reaction. Get only the ones which are</span>
0456                 I=sum(newS(allIndexes,:)~=0,2)&gt;0;
0457 
0458                 <span class="comment">%Then get the ones that are used but not in unconnected.</span>
0459                 <span class="comment">%These are metabolites that could potentially be</span>
0460                 <span class="comment">%transported to connect transMet</span>
0461                 connectedUsed=setdiff(allIndexes(I),unconnected);
0462 
0463                 <span class="comment">%I think this is an error but I leave it for now. It seems</span>
0464                 <span class="comment">%to happen if nothing can be connected in one step</span>
0465                 <span class="keyword">if</span> isempty(connectedUsed)
0466                    <span class="keyword">break</span>;
0467                 <span class="keyword">end</span>
0468 
0469                 <span class="comment">%If transMet is in the default compartment then everything</span>
0470                 <span class="comment">%is fine, just connect it to a random one</span>
0471                 <span class="keyword">if</span> transMet==dcIndex
0472                     newS=<a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting)">addTransport</a>(newS,nRxns,nER,nMets,nEM,nComps,transMet,connectedUsed(randsample(numel(connectedUsed),1)));
0473                 <span class="keyword">else</span>
0474                     <span class="comment">%If one of the connectedUsed is in the default</span>
0475                     <span class="comment">%compartment then connect to that one</span>
0476                     I=connectedUsed(connectedUsed&lt;(nMets+nEM));
0477                     <span class="keyword">if</span> any(I)
0478                         newS=<a href="addTransport.html" class="code" title="function [model, addedRxns]=addTransport(model,fromComp,toComps,metNames,isRev,onlyToExisting)">addTransport</a>(newS,nRxns,nER,nMets,nEM,nComps,transMet,I(randsample(numel(I),1)));
0479                     <span class="keyword">else</span>
0480                         <span class="comment">%This is if the only way to connect it is by adding</span>
0481                         <span class="comment">%two transport reactions, going via the default</span>
0482                         <span class="comment">%compartment</span>
0483                         <span class="keyword">break</span>;
0484                     <span class="keyword">end</span>
0485                 <span class="keyword">end</span>
0486            <span class="keyword">end</span>
0487        <span class="keyword">else</span>
0488            wasConnected=true;
0489            <span class="keyword">break</span>;
0490        <span class="keyword">end</span>
0491    <span class="keyword">end</span>
0492 
0493    <span class="comment">%If the network was connected in a new way, it is possible that some</span>
0494    <span class="comment">%transport reactions are no longer needed. They should be removed</span>
0495    <span class="keyword">if</span> wasConnected==true
0496         <span class="comment">%These are the metabolites that are being transported</span>
0497         activeTransport=find(sum(newS(:,nER+nRxns*nComps+1:end),2));
0498 
0499         <span class="comment">%Get the metabolites that are unconnected if transport wasn't used</span>
0500         unconnected=<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS(:,1:nER+nRxns*nComps),nEM);
0501 
0502         <span class="comment">%Find the transport reactions that are not needed and delete them</span>
0503         I=setdiff(activeTransport,unconnected);
0504 
0505         <span class="comment">%Since both metabolites in a transport rxns must be connected for</span>
0506         <span class="comment">%the reaction to be deleted, the sum over the colums should be 4.</span>
0507         newS(:,find(sum(newS(I,nER+nRxns*nComps+1:end))==4)+nER+nRxns*nComps)=0;
0508 
0509         <span class="comment">%Score the solution and determine whether to keep it as a new solution</span>
0510         [score, geneScore, trCost]=<a href="#_sub5" class="code" title="subfunction [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)">scoreModel</a>(newS,newg2c,GSS,transportCost);
0511 
0512         <span class="comment">%If it was the best solution so far, keep it</span>
0513         <span class="keyword">if</span> score&gt;bestScore
0514             bestScore=score;
0515             bestS=newS;
0516             bestg2c=newg2c;
0517         <span class="keyword">end</span>
0518 
0519         <span class="comment">%This should not be steepest descent later</span>
0520         <span class="keyword">if</span> score&gt;=bestScore<span class="comment">% || exp((score-bestScore)*7)&gt;rand()</span>
0521             plotScore=[plotScore;geneScore];
0522             nTrans=[nTrans;trCost];
0523             totScore=[totScore;score];
0524             S=newS;
0525             g2c=newg2c;
0526 
0527             <span class="keyword">if</span> plotResults==true
0528                 subplot(3,2,1);
0529                 spy(S);
0530                 subplot(3,2,2);
0531                 plot(plotScore,<span class="string">'r'</span>);
0532                 xlabel(<span class="string">'Gene score'</span>);
0533                 subplot(3,2,3);
0534                 plot((plotScore-minScore)/(maxScore-minScore),<span class="string">'r'</span>);
0535                 xlabel(<span class="string">'Gene score relative to predictions'</span>);
0536                 subplot(3,2,4);
0537                 plot(nTrans,<span class="string">'g'</span>);
0538                 xlabel(<span class="string">'Transport cost'</span>);
0539                 subplot(3,2,5);
0540                 plot(totScore,<span class="string">'b'</span>);
0541                 xlabel(<span class="string">'Total score'</span>);
0542                 subplot(3,2,6);
0543                 pause(0.2);
0544             <span class="keyword">end</span>
0545         <span class="keyword">end</span>
0546    <span class="keyword">end</span>
0547 <span class="keyword">end</span>
0548 scores.totScore=score;
0549 scores.geneScore=geneScore;
0550 scores.transCost=trCost;
0551 
0552 <span class="comment">%Find which metabolites are transported and to where</span>
0553 [I, J]=find(bestS(nEM+1:nEM+nMets,end-nMets*(nComps-1)+1:end));
0554 J=ceil(J/nMets+1);
0555 transportStruct.mets=model.metNames(I+nEM);
0556 transportStruct.toComp=GSS.compartments(J);
0557 
0558 [I, J]=find(bestg2c);
0559 geneLocalization.genes=GSS.genes(I);
0560 geneLocalization.comps=GSS.compartments(J);
0561 
0562 <span class="comment">%Resort the gene names</span>
0563 [~, I]=sort(geneLocalization.genes);
0564 geneLocalization.genes=geneLocalization.genes(I);
0565 geneLocalization.comps=geneLocalization.comps(I);
0566 
0567 <span class="comment">%Remove the fake genes</span>
0568 I=strncmp(<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span>,geneLocalization.genes,8);
0569 geneLocalization.genes(I)=[];
0570 geneLocalization.comps(I)=[];
0571 
0572 <span class="comment">%Put together the model. This is done by first duplicating the S matrix into the</span>
0573 <span class="comment">%different compartments. Then the transport reactions are added based on</span>
0574 <span class="comment">%transportStruct. By now model.S should have the same size as the S matrix</span>
0575 <span class="comment">%used in the optimization, but with conserved stoichiometry. In the final</span>
0576 <span class="comment">%step all reactions and metabolites that aren't used in the S matrix from the optimization</span>
0577 <span class="comment">%are deleted from the model.</span>
0578 outModel=model;
0579 outModel.S=oldS;
0580 
0581 <span class="comment">%This is the S matrix without exchange rxns or metabolites</span>
0582 copyPart=outModel.S(nEM+1:<span class="keyword">end</span>,nER+1:end);
0583 
0584 <span class="comment">%Replicate to give the rxnGeneMat for the full system</span>
0585 copyRxnGeneMat=outModel.rxnGeneMat(nER+1:<span class="keyword">end</span>,:);
0586 outModel.rxnGeneMat=[outModel.rxnGeneMat;repmat(copyRxnGeneMat,nComps-1,1)];
0587 
0588 <span class="comment">%First fix the compartments. The model is already ordered with the exchange</span>
0589 <span class="comment">%metabolites first. The original model may contain one or two compartments,</span>
0590 <span class="comment">%depending on whether any exchange metabolites are defined.</span>
0591 nStartComps=numel(outModel.comps);
0592 <span class="keyword">if</span> nStartComps==1
0593    outModel.comps={<span class="string">'1'</span>};
0594    outModel.compNames=GSS.compartments(1);
0595 <span class="keyword">else</span>
0596     <span class="keyword">if</span> model.metComps(1)==1
0597         outModel.compNames(1)=GSS.compartments(1);
0598     <span class="keyword">else</span>
0599         outModel.compNames(2)=GSS.compartments(1);
0600     <span class="keyword">end</span>
0601 <span class="keyword">end</span>
0602 outModel.compNames=[outModel.compNames;GSS.compartments(2:end)];
0603 
0604 <span class="comment">%Ugly little loop</span>
0605 <span class="keyword">for</span> i=1:numel(GSS.compartments)-1
0606     outModel.comps=[outModel.comps;num2str(numel(outModel.comps)+1)];
0607 <span class="keyword">end</span>
0608 <span class="comment">%This information is not known from the data, so empty fields are added</span>
0609 outModel.compOutside=cell(numel(outModel.comps),1);
0610 outModel.compOutside(:)={<span class="string">''</span>};
0611 
0612 <span class="keyword">for</span> i=1:nComps-1
0613     outModel.S=[outModel.S sparse(size(outModel.S,1),nRxns)];
0614     outModel.S=[outModel.S;[sparse(nMets,nRxns*i+nER) copyPart]];
0615     outModel.rxns=[outModel.rxns;strcat(outModel.rxns(nER+1:nER+nRxns),<span class="string">'_'</span>,GSS.compartments{i+1})];
0616     outModel.rxnNames=[outModel.rxnNames;strcat(outModel.rxnNames(nER+1:nER+nRxns),<span class="string">' ('</span>,GSS.compartments{i+1},<span class="string">')'</span>)];
0617     outModel.lb=[outModel.lb;outModel.lb(nER+1:nER+nRxns)];
0618     outModel.ub=[outModel.ub;outModel.ub(nER+1:nER+nRxns)];
0619     outModel.rev=[outModel.rev;outModel.rev(nER+1:nER+nRxns)];
0620     outModel.c=[outModel.c;outModel.c(nER+1:nER+nRxns)];
0621     <span class="keyword">if</span> isfield(outModel,<span class="string">'grRules'</span>)
0622         outModel.grRules=[outModel.grRules;outModel.grRules(nER+1:nER+nRxns)];
0623     <span class="keyword">end</span>
0624     <span class="keyword">if</span> isfield(outModel,<span class="string">'subSystems'</span>)
0625         outModel.subSystems=[outModel.subSystems;outModel.subSystems(nER+1:nER+nRxns)];
0626     <span class="keyword">end</span>
0627     <span class="keyword">if</span> isfield(outModel,<span class="string">'eccodes'</span>)
0628         outModel.eccodes=[outModel.eccodes;outModel.eccodes(nER+1:nER+nRxns)];
0629     <span class="keyword">end</span>
0630     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnFrom'</span>)
0631         outModel.rxnFrom=[outModel.rxnFrom;outModel.rxnFrom(nER+1:nER+nRxns)];
0632     <span class="keyword">end</span>
0633     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnMiriams'</span>)
0634         outModel.rxnMiriams=[outModel.rxnMiriams;outModel.rxnMiriams(nER+1:nER+nRxns)];
0635     <span class="keyword">end</span>
0636     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnNotes'</span>)
0637         outModel.rxnNotes=[outModel.rxnNotes;outModel.rxnNotes(nER+1:nER+nRxns)];
0638     <span class="keyword">end</span>
0639     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnReferences'</span>)
0640         outModel.rxnReferences=[outModel.rxnReferences;outModel.rxnReferences(nER+1:nER+nRxns)];
0641     <span class="keyword">end</span>
0642     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnConfidenceScores'</span>)
0643         outModel.rxnConfidenceScores=[outModel.rxnConfidenceScores;outModel.rxnConfidenceScores(nER+1:nER+nRxns)];
0644     <span class="keyword">end</span>
0645     outModel.mets=[outModel.mets;strcat(outModel.mets(nEM+1:nEM+nMets),<span class="string">'_'</span>,GSS.compartments{i+1})];
0646     outModel.metNames=[outModel.metNames;outModel.metNames(nEM+1:nEM+nMets)];
0647     outModel.b=[outModel.b;outModel.b(nEM+1:nEM+nMets,:)];
0648     I=ones(nMets,1)*nStartComps+i;
0649     outModel.metComps=[outModel.metComps;I];
0650     <span class="keyword">if</span> isfield(outModel,<span class="string">'inchis'</span>)
0651         outModel.inchis=[outModel.inchis;outModel.inchis(nEM+1:nEM+nMets)];
0652     <span class="keyword">end</span>
0653     <span class="keyword">if</span> isfield(outModel,<span class="string">'unconstrained'</span>)
0654         outModel.unconstrained=[outModel.unconstrained;outModel.unconstrained(nEM+1:nEM+nMets)];
0655     <span class="keyword">end</span>
0656     <span class="keyword">if</span> isfield(outModel,<span class="string">'metMiriams'</span>)
0657         outModel.metMiriams=[outModel.metMiriams;outModel.metMiriams(nEM+1:nEM+nMets)];
0658     <span class="keyword">end</span>
0659     <span class="keyword">if</span> isfield(outModel,<span class="string">'metFormulas'</span>)
0660         outModel.metFormulas=[outModel.metFormulas;outModel.metFormulas(nEM+1:nEM+nMets)];
0661     <span class="keyword">end</span>
0662     <span class="keyword">if</span> isfield(outModel,<span class="string">'metFrom'</span>)
0663         outModel.metFrom=[outModel.metFrom;outModel.metFrom(nEM+1:nEM+nMets)];
0664     <span class="keyword">end</span>
0665     <span class="keyword">if</span> isfield(outModel,<span class="string">'metCharges'</span>)
0666         outModel.metCharges=[outModel.metCharges;outModel.metCharges(nEM+1:nEM+nMets)];
0667     <span class="keyword">end</span>
0668 <span class="keyword">end</span>
0669 
0670 <span class="comment">%Add the transport reactions</span>
0671 transS=bestS(:,numel(outModel.rxns)+1:end);
0672 J=sum(transS)&gt;0; <span class="comment">%Active rxns</span>
0673 
0674 <span class="comment">%Transport reactions are written in a different way compared to a &quot;real&quot;</span>
0675 <span class="comment">%stoichimetric matrix. This is to fix that</span>
0676 transS(transS~=0)=1;
0677 transS(1:nEM+nMets,:)=transS(1:nEM+nMets,:)*-1;
0678 I=find(sum(transS&gt;0,2));
0679 nTransRxns=numel(I);
0680 outModel.S=[outModel.S transS(:,J)];
0681 filler=ones(nTransRxns,1);
0682 outModel.lb=[outModel.lb;filler*-1000];
0683 outModel.ub=[outModel.ub;filler*1000];
0684 outModel.rev=[outModel.rev;filler];
0685 outModel.c=[outModel.c;filler*0];
0686 outModel.rxnGeneMat=[outModel.rxnGeneMat;sparse(nTransRxns,numel(outModel.genes))];
0687 
0688 <span class="keyword">for</span> i=1:numel(I)
0689     outModel.rxns=[outModel.rxns;strcat(<span class="string">'transport'</span>,num2str(i))];
0690     outModel.rxnNames=[outModel.rxnNames;[<span class="string">'Transport of '</span>,outModel.metNames{I(i)}]];
0691     <span class="keyword">if</span> isfield(outModel,<span class="string">'grRules'</span>)
0692         outModel.grRules=[outModel.grRules;{<span class="string">''</span>}];
0693     <span class="keyword">end</span>
0694     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnMiriams'</span>)
0695         outModel.rxnMiriams=[outModel.rxnMiriams;{[]}];
0696     <span class="keyword">end</span>
0697     <span class="keyword">if</span> isfield(outModel,<span class="string">'subSystems'</span>)
0698         outModel.subSystems=[outModel.subSystems;<span class="string">'Inferred transport reactions'</span>];
0699     <span class="keyword">end</span>
0700     <span class="keyword">if</span> isfield(outModel,<span class="string">'eccodes'</span>)
0701         outModel.eccodes=[outModel.eccodes;{<span class="string">''</span>}];
0702     <span class="keyword">end</span>
0703     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnFrom'</span>)
0704         outModel.rxnFrom=[outModel.rxnFrom;{<span class="string">''</span>}];
0705     <span class="keyword">end</span>
0706     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnNotes'</span>)
0707         outModel.rxnNotes=[outModel.rxnNotes;{<span class="string">''</span>}];
0708     <span class="keyword">end</span>
0709     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnReferences'</span>)
0710         outModel.rxnReferences=[outModel.rxnReferences;{<span class="string">''</span>}];
0711     <span class="keyword">end</span>
0712     <span class="keyword">if</span> isfield(outModel,<span class="string">'rxnConfidenceScores'</span>)
0713         outModel.rxnConfidenceScores=[outModel.rxnConfidenceScores;{<span class="string">''</span>}];
0714     <span class="keyword">end</span>
0715 <span class="keyword">end</span>
0716 
0717 <span class="comment">%Then remove all reactions and metabolites that aren't used in the final</span>
0718 <span class="comment">%solution from the optimization</span>
0719 [~, J]=find(bestS(:,1:nER+nComps*nRxns));
0720 K=true(numel(outModel.rxns),1);
0721 K(J)=false;
0722 K(end-nTransRxns+1:end)=false;
0723 outModel=<a href="removeReactions.html" class="code" title="function reducedModel=removeReactions(model,rxnsToRemove,removeUnusedMets,removeUnusedGenes,removeUnusedComps)">removeReactions</a>(outModel,K,true);
0724 
0725 <span class="comment">%Remove all fake genes</span>
0726 I=strncmp(<span class="string">'&amp;&amp;FAKE&amp;&amp;'</span>,outModel.genes,8);
0727 outModel.genes(I)=[];
0728 <span class="keyword">if</span> isfield(outModel,<span class="string">'geneMiriams'</span>)
0729     outModel.geneMiriams(I)=[];
0730 <span class="keyword">end</span>
0731 <span class="keyword">if</span> isfield(outModel,<span class="string">'geneShortNames'</span>)
0732     outModel.geneShortNames(I)=[];
0733 <span class="keyword">end</span>
0734 outModel.rxnGeneMat(:,I)=[];
0735 <span class="keyword">end</span>
0736 
0737 <span class="comment">%Moves a gene and all associated reactions from one compartment to another</span>
0738 <a name="_sub1" href="#_subfunctions" class="code">function [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)</a>
0739     <span class="comment">%Find the current compartment and update to the new one</span>
0740     currentComp=find(g2c(geneToMove,:));
0741     g2c(geneToMove,:)=false;
0742     g2c(geneToMove,toComp)=true;
0743 
0744     <span class="comment">%Find the reactions in the original model that the gene controls</span>
0745     [I, ~]=find(model.rxnGeneMat(:,geneToMove));
0746 
0747     <span class="comment">%Calculate their current positions in the S matrix</span>
0748     oldRxns=I+(currentComp-1)*nRxns;
0749 
0750     <span class="comment">%And their new positions</span>
0751     newRxns=I+(toComp-1)*nRxns;
0752 
0753     <span class="comment">%The metabolite ids also have to be changed in order to match the new</span>
0754     <span class="comment">%compartment</span>
0755     metChange=nMets*(toComp-currentComp);
0756 
0757     <span class="comment">%Update the reactions</span>
0758     [I, J, K]=find(S(:,oldRxns));
0759     I=I+metChange;
0760 
0761     <span class="comment">%Move the reactions</span>
0762     S(:,oldRxns)=0;
0763     S(sub2ind(size(S),I,newRxns(J)))=K;
0764 <span class="keyword">end</span>
0765 
0766 <span class="comment">%Finds which metabolites are unconnected, in the sense that they are never</span>
0767 <span class="comment">%a product or only a product in a reversible reaction where one reactant is</span>
0768 <span class="comment">%only a product in the opposite direction of that reaction. This function</span>
0769 <span class="comment">%ignores exchange metabolites. Returns a vector of metabolite indexes.</span>
0770 <span class="comment">%metsToCheck is an array of metabolite indexes to check for connectivity.</span>
0771 <span class="comment">%If not supplied then all metabolites are checked</span>
0772 <a name="_sub2" href="#_subfunctions" class="code">function unconnected=findUnconnected(S,nEM,metsToCheck)</a>
0773     <span class="keyword">if</span> nargin&gt;2
0774         <span class="comment">%Do this by deleting everything from the network that is not in</span>
0775         <span class="comment">%metsToCheck and that is not exchange metabolites</span>
0776         I=false(size(S,1),1);
0777         I(1:nEM)=true;
0778         I(metsToCheck)=true;
0779         S=S(I,:);
0780     <span class="keyword">end</span>
0781 
0782     em=false(size(S,1),1);
0783     em(1:nEM)=true;
0784 
0785     <span class="comment">%Construct a matrix in which the reversible reactions are inverted</span>
0786     I=sum(S&gt;2,1) | sum(S&gt;2,1);
0787     revS=S;
0788     revS(:,I)=revS(:,I)*-1;
0789 
0790     <span class="comment">%First calculate the ones that are ok</span>
0791     <span class="comment">%Produced in 2 rxns, is exchange, is not used at all, is produced in</span>
0792     <span class="comment">%non-reversible, involved in more than 1 reversible reactions</span>
0793     connected=sum(S&gt;0,2)&gt;1 | em | sum(S~=0,2)==0 | sum(S(:,~I)&gt;0,2)&gt;0 | sum(S(:,I)~=0,2)&gt;1;
0794 
0795     <span class="comment">%Then get the ones that are unconnected because they are never produced</span>
0796     unconnected=sum(S&gt;0 | revS&gt;0,2)==0 &amp; connected==false;
0797 
0798     <span class="comment">%Then get the ones that are potentially unconnected</span>
0799     maybeUnconnected=~connected &amp; ~unconnected;
0800     <span class="comment">%maybeUnconnected=find(maybeUnconnectedS);</span>
0801 
0802     <span class="comment">%The metabolites in maybeUnconnected are involved in one reversible reaction and</span>
0803     <span class="comment">%not produced in any other reaction.</span>
0804     <span class="comment">%This means that the reactions which have at least one met in</span>
0805     <span class="comment">%maybeUnconnected as reactant and one as product are unconnected. The</span>
0806     <span class="comment">%metabolites in maybeUnconnected that are present in those reactions</span>
0807     <span class="comment">%are then dead ends</span>
0808     deadRxns=any(S(maybeUnconnected,:)&gt;0) &amp; any(S(maybeUnconnected,:)&lt;0);
0809 
0810     <span class="comment">%Get the mets involved in any of those reactions</span>
0811     problematic=any(S(:,deadRxns)~=0,2);
0812 
0813     <span class="comment">%If any of these are in the maybeUnconnected list then the</span>
0814     <span class="comment">%metabolite is unconnected</span>
0815     unconnected(problematic &amp; maybeUnconnected)=true;
0816 
0817     <span class="comment">%Map back to metsToCheck</span>
0818     <span class="keyword">if</span> nargin&gt;2
0819         unconnected=metsToCheck(unconnected(nEM+1:end));
0820     <span class="keyword">else</span>
0821         unconnected=find(unconnected);
0822     <span class="keyword">end</span>
0823 <span class="keyword">end</span>
0824 
0825 <span class="comment">%Given a set of unconnected metabolites, this function tries to move each</span>
0826 <span class="comment">%gene that could connect any of them, calculates the number of newly connected</span>
0827 <span class="comment">%metabolites minus the number of newly disconnected metabolites. As some metabolites</span>
0828 <span class="comment">%are very connected, only 25 genes are checked. Genes that have a low score</span>
0829 <span class="comment">%in their current compartment are more likely to be moved.</span>
0830 <a name="_sub3" href="#_subfunctions" class="code">function [geneIndex, moveTo, deltaConnected, deltaScore]=selectGenes(S,nEM,nMets,nER,nRxns,model,unconnected,g2c,GSS)</a>
0831     <span class="comment">%If moveTo is 0 then the gene can't connect any of the metabolites</span>
0832     moveTo=zeros(numel(model.genes),1);
0833     deltaConnected=zeros(numel(model.genes),1);
0834 
0835     <span class="comment">%First get where the metabolites are now</span>
0836     nComps=size(g2c,2);
0837     comps=ceil((unconnected-nEM)/((size(S,1)-nEM)/nComps));
0838 
0839     <span class="comment">%Find the corresponding metabolite indexes if they all were in the</span>
0840     <span class="comment">%default compartment</span>
0841     dcIndexes=unique(unconnected-(comps-1)*nMets);
0842 
0843     <span class="comment">%Then find them if they were in any other compartment</span>
0844     allIndexes=dcIndexes;
0845     <span class="keyword">for</span> i=1:nComps-1
0846        allIndexes=[allIndexes;dcIndexes+nMets*i];
0847     <span class="keyword">end</span>
0848 
0849     <span class="comment">%Also check which reversible reactions that could be used</span>
0850     I=sum(S&gt;2,1) | sum(S&gt;2,1);
0851     revS=S;
0852     revS(:,I)=revS(:,I)*-1;
0853 
0854     <span class="comment">%Find all reactions that could make any of the unconnected metabolites</span>
0855     <span class="comment">%in some other compartment</span>
0856     newMets=setdiff(allIndexes,unconnected);
0857     [~, potential]=find(S(newMets,:)&gt;0 | revS(newMets,:)&gt;0);
0858     potential(potential&lt;=nER | potential&gt;nER+nRxns*nComps)=[]; <span class="comment">%No exchange rxns or transport rxns</span>
0859 
0860     <span class="comment">%Map J to the real metabolic reactions in model</span>
0861     rxnComps=ceil((potential-nER)/(nRxns));
0862 
0863     <span class="comment">%Find the corresponding reaction indexes if they all were in the</span>
0864     <span class="comment">%default compartment</span>
0865     dcRxnIndexes=potential-(rxnComps-1)*nRxns;
0866 
0867     <span class="comment">%Get the genes for those reactions</span>
0868     genes=find(sum(model.rxnGeneMat(dcRxnIndexes,:)&gt;0,1));
0869 
0870     <span class="comment">%For some cases there can be very many reactions to connect something.</span>
0871     <span class="comment">%This is in particular true in the beginning of the optimization if,</span>
0872     <span class="comment">%say, ATP is unconnected. Therefore limit the number of genes to be</span>
0873     <span class="comment">%checked to 25. Weigh so that genes with bad scores in their current</span>
0874     <span class="comment">%compartment are more likely to be moved</span>
0875 
0876     <span class="comment">%Get scores for these genes</span>
0877     [~, J]=find(g2c(genes,:));
0878 
0879     <span class="comment">%Add a small weight so that genes in their best compartment could be</span>
0880     <span class="comment">%moved as well</span>
0881     geneScores=GSS.scores(sub2ind(size(g2c),genes(:),J));
0882     modGeneScores=1.1-geneScores;
0883     <span class="keyword">if</span> numel(genes)&gt;25
0884         rGenes=genes(randsample(numel(genes),min(numel(genes),25),true,modGeneScores));
0885 
0886         <span class="comment">%The sampling with weights could give duplicates</span>
0887         rGenes=unique(rGenes);
0888 
0889         <span class="comment">%Reorder the geneScores to match</span>
0890         [~, I]=ismember(rGenes,genes);
0891         geneScores=geneScores(I);
0892         genes=rGenes;
0893     <span class="keyword">end</span>
0894     <span class="keyword">for</span> i=1:numel(genes)
0895         <span class="comment">%Since we are moving one gene at a time, only metabolites involved</span>
0896         <span class="comment">%in any of the reactions for that gene can become unconnected. We</span>
0897         <span class="comment">%get them so speed up the algorithm.</span>
0898         <span class="comment">%First get all involved reactions in the default compartment</span>
0899         rxns=find(model.rxnGeneMat(:,genes(i)));
0900 
0901         <span class="comment">%Then get their mets</span>
0902         mets=find(sum(model.S(:,rxns)~=0,2)&gt;0);
0903 
0904         <span class="comment">%Then get their indexes in all compartments</span>
0905         allIndexes=mets;
0906         <span class="keyword">for</span> j=1:nComps-1
0907            allIndexes=[allIndexes;mets+nMets*j];
0908         <span class="keyword">end</span>
0909 
0910         <span class="comment">%Check which of the unconnected metabolites that these</span>
0911         <span class="comment">%reactions correspond to. This could have been done earlier,</span>
0912         <span class="comment">%but it's fast. I skip the reversibility check because it's</span>
0913         <span class="comment">%unlikely to be an issue here. Worst case is that the gene is</span>
0914         <span class="comment">%tested once to much</span>
0915         [I, ~]=find(model.S(:,rxns));
0916         moveToComps=unique(comps(ismember(dcIndexes,I)));
0917 
0918         <span class="comment">%Try to move the gene to each of the compartments</span>
0919         bestMove=-inf;
0920         bestComp=[];
0921         <span class="keyword">for</span> j=1:numel(moveToComps)
0922             newS=<a href="#_sub1" class="code" title="subfunction [S, g2c]=moveGene(S,model,g2c,geneToMove,toComp,nRxns,nMets)">moveGene</a>(S,model,g2c,genes(i),moveToComps(j),nRxns,nMets);
0923 
0924             <span class="comment">%Check how many metabolites that are unconnected after moving</span>
0925             <span class="comment">%the gene</span>
0926             dConnected=numel(unconnected)-numel(<a href="#_sub2" class="code" title="subfunction unconnected=findUnconnected(S,nEM,metsToCheck)">findUnconnected</a>(newS,nEM,[allIndexes;unconnected]));
0927             <span class="keyword">if</span> dConnected&gt;bestMove
0928                 bestMove=dConnected;
0929                 bestComp=moveToComps(j);
0930             <span class="keyword">end</span>
0931         <span class="keyword">end</span>
0932 
0933         <span class="comment">%Add the difference in connectivity and where the genes should</span>
0934         <span class="comment">%be moved</span>
0935         moveTo(genes(i))=bestComp;
0936         deltaConnected(genes(i))=bestMove;
0937     <span class="keyword">end</span>
0938 
0939     <span class="comment">%Finish up</span>
0940     geneIndex=genes(:);
0941     moveTo=moveTo(geneIndex);
0942     deltaConnected=deltaConnected(geneIndex);
0943     deltaScore=GSS.scores(sub2ind(size(g2c),geneIndex(:),moveTo))-geneScores;
0944 <span class="keyword">end</span>
0945 
0946 <span class="comment">%Small function to add a transport reactions between two metabolites.</span>
0947 <span class="comment">%Transport reactions are written as having a coefficient 2.0 for both</span>
0948 <span class="comment">%reactant and product. This is not a &quot;real&quot; reaction, but since all normal</span>
0949 <span class="comment">%reaction have coefficient -1/1 or -10/10 it's a compact way of writing it.</span>
0950 <a name="_sub4" href="#_subfunctions" class="code">function S=addTransport(S,nRxns,nER,nMets,nEM,nComps,metA,metB)</a>
0951     mets=[metA;metB];
0952     <span class="comment">%Find the current compartments for the metabolites</span>
0953     comps=ceil((mets-nEM)/((size(S,1)-nEM)/nComps));
0954 
0955     <span class="keyword">if</span> sum(comps==1)~=1
0956         EM=<span class="string">'Tried to create a transport reaction from a non-default compartment'</span>;
0957       <a href="dispEM.html" class="code" title="function dispEM(string,throwErrors,toList,trimWarnings)">dispEM</a>(EM);
0958     <span class="keyword">end</span>
0959 
0960     <span class="comment">%Calculate the reaction index</span>
0961     rIndex=(nER+nRxns*nComps)+mets(comps~=1)-nEM-nMets;
0962 
0963     S(mets,rIndex)=2;
0964 <span class="keyword">end</span>
0965 
0966 <span class="comment">%Scores a network based on the localization of the genes and the number of</span>
0967 <span class="comment">%transporter reactions used.</span>
0968 <a name="_sub5" href="#_subfunctions" class="code">function [score, geneScore, transportCost]=scoreModel(S,g2c,GSS,transportCost)</a>
0969     [I, J]=find(g2c);
0970     geneScore=sum(GSS.scores(sub2ind(size(g2c),I,J)));
0971     [I, ~]=find(S==2);
0972     I=unique(I);
0973     transportCost=sum(transportCost(I));
0974     score=geneScore-transportCost;
0975 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 14-Mar-2018 21:08:28 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>