<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of optimizeProb</title>
  <meta name="keywords" content="optimizeProb">
  <meta name="description" content="optimizeProb">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">solver</a> &gt; optimizeProb.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for solver&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>optimizeProb
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>optimizeProb</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function res = optimizeProb(prob,params,verbose) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> optimizeProb
   Optimize an LP or MILP formulated in cobra terms.

   prob    cobra style LP/MILP problem struct to be optimised
   params    solver specific parameters (optional)
   verbose if true MILP progress is shown (opt, default true)

   res        the output structure from the selected solver RAVENSOLVER
           (cobra style)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="solveLP.html" class="code" title="function [solution, hsSolOut]=solveLP(model,minFlux,params,hsSol)">solveLP</a>	solveLP</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function s_merged=structUpdate(s_old,s_new)</a></li><li><a href="#_sub2" class="code">function paramlist = renameparams(paramlist,old,new)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function res = optimizeProb(prob,params,verbose)</a>
0002 <span class="comment">% optimizeProb</span>
0003 <span class="comment">%   Optimize an LP or MILP formulated in cobra terms.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%   prob    cobra style LP/MILP problem struct to be optimised</span>
0006 <span class="comment">%   params    solver specific parameters (optional)</span>
0007 <span class="comment">%   verbose if true MILP progress is shown (opt, default true)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   res        the output structure from the selected solver RAVENSOLVER</span>
0010 <span class="comment">%           (cobra style)</span>
0011 
0012 <span class="keyword">if</span> nargin&lt;2 || isempty(params)
0013     params=struct();
0014 <span class="keyword">end</span>
0015 <span class="keyword">if</span> nargin&lt;3 || isempty(verbose)
0016     verbose = true;
0017 <span class="keyword">end</span>
0018 
0019 <span class="comment">%Set as global variable for speed improvement if optimizeProb is run many times</span>
0020 <span class="keyword">global</span> RAVENSOLVER;
0021 <span class="keyword">if</span> isempty(RAVENSOLVER)
0022     <span class="keyword">if</span>(~ispref(<span class="string">'RAVEN'</span>,<span class="string">'solver'</span>))
0023         dispEM(<span class="string">'RAVEN solver not defined or unknown. Try using setRavenSolver(''solver'').'</span>);
0024     <span class="keyword">else</span>
0025         RAVENSOLVER = getpref(<span class="string">'RAVEN'</span>,<span class="string">'solver'</span>);
0026     <span class="keyword">end</span>
0027 <span class="keyword">end</span>
0028 solver=RAVENSOLVER;
0029 
0030 <span class="keyword">if</span> ~all(lower(prob.vartype) == <span class="string">'c'</span>)
0031     milp=true;
0032 <span class="keyword">else</span>
0033     milp=false;
0034 <span class="keyword">end</span>
0035 
0036 <span class="comment">%% Define default parameters, which will then be used to make solver-</span>
0037 <span class="comment">% specific solverparams structures</span>
0038 defaultparams.feasTol        = 1e-9;
0039 defaultparams.optTol         = 1e-9;
0040 defaultparams.objTol         = 1e-6;
0041 defaultparams.timeLimit      = 1000;
0042 <span class="comment">%defaultparams.iterationLimit = 1000;</span>
0043 defaultparams.intTol         = 1e-12;
0044 defaultparams.relMipGapTol   = 1e-12;
0045 defaultparams.absMipGapTol   = 1e-12;
0046 <span class="keyword">if</span> milp
0047     defaultparams.MIPGap     = 1e-12;
0048     defaultparams.Seed       = 1;
0049 <span class="keyword">end</span>
0050 
0051 <span class="keyword">switch</span> solver
0052     <span class="comment">%% Use whatever solver is set by COBRA Toolbox changeCobraSolver</span>
0053     <span class="keyword">case</span> <span class="string">'cobra'</span>
0054         <span class="keyword">if</span> milp
0055             cparams=struct(<span class="string">'timeLimit'</span>,1e9,<span class="string">'printLevel'</span>,0,<span class="string">'intTol'</span>,1e-6,<span class="string">'relMipGapTol'</span>,1e-9);
0056             cparams=<a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(cparams,params);
0057             res=solveCobraMILP(prob,cparams);
0058         <span class="keyword">else</span>
0059             res=solveCobraLP(prob);
0060         <span class="keyword">end</span>
0061         <span class="keyword">if</span> isfield(res,{<span class="string">'dual'</span>,<span class="string">'rcost'</span>})
0062             res.dual=res.dual;
0063             res.rcost=res.rcost;
0064         <span class="keyword">end</span>
0065 
0066         <span class="comment">%% Use Gurobi in a MATLAB environment</span>
0067     <span class="keyword">case</span> <span class="string">'gurobi'</span>
0068         <span class="keyword">if</span> milp
0069             <span class="keyword">if</span> verbose
0070                 solverparams.OutputFlag = 1;
0071             <span class="keyword">else</span>
0072                 solverparams.OutputFlag = 0;
0073             <span class="keyword">end</span>
0074             solverparams.IntFeasTol = 10^-9; <span class="comment">%min val for gurobi</span>
0075             solverparams.MIPGap = defaultparams.MIPGap;
0076             solverparams.Seed = defaultparams.Seed;
0077         <span class="keyword">else</span>
0078             solverparams.OutputFlag = 0;
0079         <span class="keyword">end</span>
0080         solverparams.DisplayInterval= 1; <span class="comment">% Level of verbosity</span>
0081         solverparams.TimeLimit      = defaultparams.timeLimit;
0082         solverparams.FeasibilityTol = defaultparams.feasTol;
0083         solverparams.OptimalityTol  = defaultparams.optTol;
0084         solverparams.Presolve       = 2;
0085         solverparams = <a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(solverparams,params);
0086 
0087         <span class="comment">% Restructering problem according to gurobi format</span>
0088         <span class="keyword">if</span> isfield(prob, <span class="string">'csense'</span>)
0089             prob.sense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(prob.csense, {<span class="string">'L'</span>,<span class="string">'G'</span>,<span class="string">'E'</span>}, {<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'='</span>});
0090             prob = rmfield(prob, {<span class="string">'csense'</span>});
0091         <span class="keyword">end</span>
0092         <span class="keyword">if</span> isfield(prob, <span class="string">'osense'</span>)
0093             osense = prob.osense;
0094             prob.modelsense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(num2str(prob.osense), {<span class="string">'1'</span>,<span class="string">'-1'</span>}, {<span class="string">'min'</span>,<span class="string">'max'</span>});
0095             prob = rmfield(prob, {<span class="string">'osense'</span>});
0096         <span class="keyword">end</span>
0097         [prob.obj, prob.rhs, prob.vtype] = deal(prob.c, prob.b, prob.vartype);
0098         prob = rmfield(prob, {<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'vartype'</span>});
0099 
0100         resG = gurobi(prob,solverparams);
0101 
0102         <span class="keyword">try</span>
0103             <span class="comment">% Name output fields the same as COBRA does</span>
0104             res.full     = resG.x;
0105             res.obj      = resG.objval;
0106             res.origStat = resG.status;
0107             <span class="keyword">if</span> isfield(resG,{<span class="string">'pi'</span>,<span class="string">'rc'</span>})
0108                 res.dual     = -resG.pi*osense;
0109                 res.rcost    = -resG.rc*osense;
0110             <span class="keyword">end</span>
0111             <span class="keyword">if</span> milp &amp;&amp; strcmp(resG.status, <span class="string">'TIME_LIMIT'</span>)
0112                 <span class="comment">% If res has the objval field, it succeeded, regardless of</span>
0113                 <span class="comment">% time_limit status</span>
0114                 resG.status = <span class="string">'OPTIMAL'</span>;
0115             <span class="keyword">end</span>
0116             <span class="keyword">switch</span> resG.status
0117                 <span class="keyword">case</span> <span class="string">'OPTIMAL'</span>
0118                     res.stat = 1;
0119                 <span class="keyword">case</span> <span class="string">'UNBOUNDED'</span>
0120                     res.stat = 2;
0121                 <span class="keyword">otherwise</span>
0122                     res.stat = 0;
0123             <span class="keyword">end</span>
0124             <span class="keyword">if</span> ~milp
0125                 res.vbasis = resG.vbasis;
0126                 res.cbasis = resG.cbasis;
0127             <span class="keyword">else</span>
0128                 res.mipgap = resG.mipgap;
0129             <span class="keyword">end</span>
0130         <span class="keyword">catch</span>
0131             res.stat = 0;
0132             res.origStat = resG.status;  <span class="comment">% useful information to have</span>
0133         <span class="keyword">end</span>
0134         <span class="comment">%% Use GLPK using RAVEN-provided binary</span>
0135     <span class="keyword">case</span> <span class="string">'glpk'</span>
0136         solverparams.scale   = 1; <span class="comment">% Auto scaling</span>
0137         solverparams.tmlim   = defaultparams.timeLimit;
0138         solverparams.tolbnd  = defaultparams.feasTol;
0139         solverparams.toldj   = defaultparams.optTol;
0140         solverparams.tolint  = defaultparams.intTol;
0141         solverparams.tolobj  = defaultparams.objTol;
0142         solverparams.msglev  = 0; <span class="comment">% Level of verbosity</span>
0143         solverparams = <a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(solverparams,params);
0144 
0145         prob.csense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(prob.csense, {<span class="string">'L'</span>,<span class="string">'G'</span>,<span class="string">'E'</span>}, {<span class="string">'U'</span>,<span class="string">'L'</span>,<span class="string">'S'</span>});
0146 
0147         <span class="keyword">if</span> milp
0148             solverparams.tmlim   = solverparams.tmlim*10;
0149             solverparams.msglev  = 1; <span class="comment">% Level of verbosity</span>
0150             disp(<span class="string">'Issues have been observed when using GLPK for MILP solving. Be advised to carefully observe the results, or us another solver.'</span>)
0151         <span class="keyword">end</span>
0152 
0153         <span class="comment">% Ensure that RAVEN glpk binary is used, return to original</span>
0154         <span class="comment">% directory afterwards</span>
0155         [ravenDir,currDir]=findRAVENroot();
0156         cd(fullfile(ravenDir,<span class="string">'software'</span>,<span class="string">'GLPKmex'</span>))
0157         [xopt, fmin, errnum, extra] = glpk(prob.c, prob.A, prob.b, prob.lb, prob.ub, prob.csense, prob.vartype, prob.osense, solverparams);
0158         cd(currDir)
0159 
0160         <span class="keyword">switch</span> errnum <span class="comment">% 1 = undefined; 2 = feasible; 3 = infeasible; 4 = no feasible solution; 5 = optimal; 6 = no unbounded solution</span>
0161             <span class="keyword">case</span> 5
0162                 res.stat = 1; <span class="comment">% Optimal</span>
0163             <span class="keyword">case</span> 2
0164                 res.stat = 2; <span class="comment">% Feasible, but not optimal</span>
0165             <span class="keyword">otherwise</span>
0166                 res.stat = 0;
0167         <span class="keyword">end</span>
0168         res.origStat = errnum;
0169         res.full     = xopt;
0170         res.obj      = fmin;
0171         res.dual     = -extra.lambda*prob.osense;
0172         res.rcost    = -extra.redcosts*prob.osense;
0173         <span class="comment">%% Use SoPlex</span>
0174     <span class="keyword">case</span> {<span class="string">'soplex'</span>,<span class="string">'scip'</span>}
0175         [xopt,fval,exitflag,stats] = scip([], prob.c, prob.A,-prob.b, prob.b, prob.lb, prob.ub, prob.vartype);
0176         fprintf(<span class="string">'#'</span>)
0177 
0178 <span class="comment">%   [x,fval,exitflag,stats] = scip(H, f, A, rl, ru, lb, ub, xtype, sos, qc, nl, x0, opts)</span>
0179 <span class="comment">%</span>
0180 <span class="comment">%   Input arguments*:</span>
0181 <span class="comment">%       H - quadratic objective matrix (sparse, optional [NOT TRIL / TRIU])</span>
0182 <span class="comment">%       f - linear objective vector</span>
0183 <span class="comment">%       A - linear constraint matrix (sparse)</span>
0184 <span class="comment">%       rl - linear constraint lhs</span>
0185 <span class="comment">%       ru - linear constraint rhs</span>
0186 <span class="comment">%       lb - decision variable lower bounds</span>
0187 <span class="comment">%       ub - decision variable upper bounds</span>
0188 <span class="comment">%       xtype - string of variable integrality ('c' continuous, 'i' integer, 'b' binary)</span>
0189 <span class="comment">%       sos - SOS structure with fields type, index and weight (see below)</span>
0190 <span class="comment">%       qc - Quadratic Constraints structure with fields Q, l, qrl and qru (see below)</span>
0191 <span class="comment">%       nl - Nonlinear Objective and Constraints structure (see below)</span>
0192 <span class="comment">%       x0 - primal solution</span>
0193 <span class="comment">%       opts - solver options (see below)</span>
0194 <span class="comment">%</span>
0195 <span class="comment">%   Return arguments:</span>
0196 <span class="comment">%       x - solution vector</span>
0197 <span class="comment">%       fval - objective value at the solution</span>
0198 <span class="comment">%       exitflag - exit status (see below)</span>
0199 <span class="comment">%       stats - statistics structure</span>
0200 <span class="comment">%</span>
0201 <span class="comment">%   Option Fields (all optional, see also optiset for a list):</span>
0202 <span class="comment">%       solverOpts - specific SCIP options (list of pairs of parameter names and values)</span>
0203 <span class="comment">%       maxiter - maximum LP solver iterations</span>
0204 <span class="comment">%       maxnodes - maximum nodes to explore</span>
0205 <span class="comment">%       maxtime - maximum execution time [s]</span>
0206 <span class="comment">%       tolrfun - primal feasibility tolerance</span>
0207 <span class="comment">%       display - solver display level [0-5]</span>
0208 <span class="comment">%       probfile - write problem to given file</span>
0209 <span class="comment">%       presolvedfile - write presolved problem to file</span>
0210 <span class="comment">%</span>
0211 <span class="comment">%   Return Status:</span>
0212 <span class="comment">%       0 - Unknown</span>
0213 <span class="comment">%       1 - User Interrupted</span>
0214 <span class="comment">%       2 - Node Limit Reached</span>
0215 <span class="comment">%       3 - Total Node Limit Reached</span>
0216 <span class="comment">%       4 - Stall Node Limit Reached</span>
0217 <span class="comment">%       5 - Time Limit Reached</span>
0218 <span class="comment">%       6 - Memory Limit Reached</span>
0219 <span class="comment">%       7 - Gap Limit Reached</span>
0220 <span class="comment">%       8 - Solution Limit Reached</span>
0221 <span class="comment">%       9 - Solution Improvement Limit Reached</span>
0222 <span class="comment">%      10 - Restart Limit Reached</span>
0223 <span class="comment">%      11 - Problem Solved to Optimality</span>
0224 <span class="comment">%      12 - Problem is Infeasible</span>
0225 <span class="comment">%      13 - Problem is Unbounded</span>
0226 <span class="comment">%      14 - Problem is Either Infeasible or Unbounded</span>
0227         
0228         res.origStat = exitflag;
0229         res.full = xopt;
0230         res.obj  = fval;
0231 
0232         <span class="keyword">switch</span> exitflag
0233             <span class="keyword">case</span> 11
0234                 res.stat = 1;
0235             <span class="keyword">case</span> [5, 6, 7, 8, 9, 10, 13]
0236                 res.stat = 2;
0237             <span class="keyword">otherwise</span>
0238                 res.stat = 0;
0239         <span class="keyword">end</span>
0240         
0241         <span class="comment">% OLD SOPLEX IMPLEMENTATION</span>
0242         <span class="comment">% solverparams.tmlim   = 1;</span>
0243         <span class="comment">% solverparams.save    = 1;</span>
0244         <span class="comment">% solverparams = structUpdate(solverparams,params);</span>
0245         <span class="comment">% prob.csense = renameparams(prob.csense, {'L','G','E'}, {'U','L','S'});</span>
0246         <span class="comment">%</span>
0247         <span class="comment">% [ravenDir,currDir]=findRAVENroot();</span>
0248         <span class="comment">% cd(fullfile(ravenDir,'software','GLPKmex'))</span>
0249         <span class="comment">% glpk(prob.c, prob.A, prob.b, prob.lb, prob.ub, prob.csense, prob.vartype, prob.osense, solverparams);</span>
0250         <span class="comment">% solverparams.tmlim   = defaultparams.timeLimit;</span>
0251         <span class="comment">% cd(fullfile(ravenDir,'software','soplex'))</span>
0252         <span class="comment">% movefile(fullfile(ravenDir,'software','GLPKmex','outpb.lp'),'outpb.lp')</span>
0253         <span class="comment">% [runCheck, cmdOut]  = system(['soplex --solvemode=2 -t' num2str(solverparams.tmlim) ' -x outpb.lp &gt; result.out']);</span>
0254         <span class="comment">%</span>
0255         <span class="comment">% if runCheck ~= 0</span>
0256         <span class="comment">%     error('SoPlex did not run')</span>
0257         <span class="comment">% end</span>
0258         <span class="comment">% if verLessThan('matlab','9.9') %readlines introduced 2020b</span>
0259         <span class="comment">%     fid=fopen('result.out');</span>
0260         <span class="comment">%     line_raw=cell(1000000,1);</span>
0261         <span class="comment">%     i=1;</span>
0262         <span class="comment">%     while ~feof(fid)</span>
0263         <span class="comment">%         line_raw{i}=fgetl(fid);</span>
0264         <span class="comment">%         i=i+1;</span>
0265         <span class="comment">%     end</span>
0266         <span class="comment">%     line_raw(i:end)=[];</span>
0267         <span class="comment">%     line_raw=string(line_raw);</span>
0268         <span class="comment">% else</span>
0269         <span class="comment">%     %line_raw=readlines('result.out','EmptyLineRule','skip','WhitespaceRule','trim');</span>
0270         <span class="comment">%     line_raw=readlines('result.out');</span>
0271         <span class="comment">% end</span>
0272         <span class="comment">% delete 'result.out'</span>
0273         <span class="comment">% delete 'outpb.lp'</span>
0274         <span class="comment">% cd(currDir)</span>
0275         <span class="comment">%</span>
0276         <span class="comment">% if find(contains(line_raw,'problem is solved [optimal]'),1) &gt; 0</span>
0277         <span class="comment">%     res.full = zeros(length(prob.c),1);</span>
0278         <span class="comment">%     res.stat = 1;</span>
0279         <span class="comment">%     obj_line = line_raw{contains(line_raw,'Objective value')};</span>
0280         <span class="comment">%     res.obj  = str2double(obj_line(strfind(obj_line,':')+2:end));</span>
0281         <span class="comment">%     a        = find(contains(line_raw,'Primal solution (name, value):'));</span>
0282         <span class="comment">%     z        = find(contains(line_raw,'All other variables are zero'));</span>
0283         <span class="comment">%     flux     = split(line_raw(a+1:z-1));</span>
0284         <span class="comment">%     rxns     = str2double(replace(flux(:,1),'x_',''));</span>
0285         <span class="comment">%     flux     = str2double(flux(:,2));</span>
0286         <span class="comment">%     res.full(rxns) = flux;</span>
0287         <span class="comment">% elseif ~isempty(cmdOut)</span>
0288         <span class="comment">%     error(['SoPlex error: ' extractBefore(cmdOut,newline)])</span>
0289         <span class="comment">% else</span>
0290         <span class="comment">%     statusLine = contains(line_raw,'SoPlex status');</span>
0291         <span class="comment">%     if ~strcmp(line_raw(statusLine),'SoPlex status       : problem is solved [infeasible]')</span>
0292         <span class="comment">%         disp(line_raw(statusLine)); % Only print if any other status message is shown</span>
0293         <span class="comment">%     end</span>
0294         <span class="comment">%     res.stat = 0;</span>
0295         <span class="comment">%     res.obj  = [];</span>
0296         <span class="comment">%     res.full = [];</span>
0297         <span class="comment">% end</span>
0298 
0299     <span class="keyword">otherwise</span>
0300         error(<span class="string">'RAVEN solver not defined or unknown. Try using setRavenSolver(''solver'').'</span>);
0301 <span class="keyword">end</span>
0302 <span class="keyword">if</span> res.stat&gt;0
0303     res.full=res.full(1:size(prob.a,2));
0304 <span class="keyword">end</span>
0305 <span class="keyword">end</span>
0306 
0307 <a name="_sub1" href="#_subfunctions" class="code">function s_merged=structUpdate(s_old,s_new)</a>
0308 <span class="comment">%Remove overlapping fields from first struct;</span>
0309 <span class="comment">%Obtain all unique names of remaining fields;</span>
0310 <span class="comment">%Merge both structs</span>
0311 s_merged = rmfield(s_old, intersect(fieldnames(s_old), fieldnames(s_new)));
0312 names = [fieldnames(s_merged); fieldnames(s_new)];
0313 s_merged = cell2struct([struct2cell(s_merged); struct2cell(s_new)], names, 1);
0314 <span class="keyword">end</span>
0315 
0316 <a name="_sub2" href="#_subfunctions" class="code">function paramlist = renameparams(paramlist,old,new)</a>
0317 <span class="keyword">if</span> ~iscell(paramlist)
0318     wasNoCell = true;
0319     paramlist={paramlist};
0320 <span class="keyword">else</span>
0321     wasNoCell = false;
0322 <span class="keyword">end</span>
0323 <span class="keyword">for</span> i=1:numel(old)
0324     paramlist = regexprep(paramlist,old{i},new{i});
0325 <span class="keyword">end</span>
0326 <span class="keyword">if</span> wasNoCell
0327     paramlist=paramlist{1};
0328 <span class="keyword">end</span>
0329 <span class="keyword">end</span></pre></div>
<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>