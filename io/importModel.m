function model=importModel(fileName,removeExcMets,isSBML2COBRA,supressWarnings)
% importModel
%   Import a constraint-based model from a SBML file
%
%   fileName        a SBML file to import
%   removeExcMets   true if exchange metabolites should be removed. This is
%                   needed to be able to run simulations, but it could also
%                   be done using simplifyModel at a later stage (opt,
%                   default true)
%   isSBML2COBRA    true if the SBML file is in the old COBRA Toolbox format
%                   (SBML Level 2) (opt, default false)
%   supressWarnings true if warnings regarding the model structure should
%                   be supressed (opt, default false)
%
%   model
%       id               model ID
%       description      description of model contents
%       annotation       additional information about model
%       rxns             reaction ids
%       mets             metabolite ids
%       S                stoichiometric matrix
%       lb               lower bounds
%       ub               upper bounds
%       rev              reversibility vector
%       c                objective coefficients
%       b                equality constraints for the metabolite equations
%       comps            compartment ids
%       compNames        compartment names
%       compOutside      the id (as in comps) for the compartment
%                        surrounding each of the compartments
%       compMiriams      structure with MIRIAM information about the
%                        compartments
%       rxnNames         reaction description
%       rxnComps         compartments for reactions
%       grRules          reaction to gene rules in text form
%       rxnGeneMat       reaction-to-gene mapping in sparse matrix form
%       subSystems       subsystem name for each reaction
%       eccodes          EC-codes for the reactions
%       rxnMiriams       structure with MIRIAM information about the reactions
%       rxnNotes         reaction notes
%       rxnReferences	 reaction references
%       rxnConfidenceScores reaction confidence scores
%       genes            list of all genes
%       geneComps        compartments for genes
%       geneMiriams      structure with MIRIAM information about the genes
%       geneShortNames   gene alternative names (e.g. ERG10)
%       metNames         metabolite description
%       metComps         compartments for metabolites
%       inchis           InChI-codes for metabolites
%       metFormulas      metabolite chemical formula
%       metMiriams       structure with MIRIAM information about the metabolites
%       metCharges       metabolite charge
%       unconstrained    true if the metabolite is an exchange metabolite
%
%   Loads models in the COBRA Toolbox format and in the format used in
%   the yeast consensus reconstruction. The resulting structure is compatible
%   with COBRA Toolbox. A number of consistency checks are performed in order
%   to ensure that the model is valid. Take these warnings seriously and modify the
%   model structure to solve them. The RAVEN Toolbox is made to function
%   only on consistent models, and the only checks performed are when the
%   model is imported. You can use exportToExcelFormat, modify the model in
%   Microsoft Excel and then reimport it using importExcelModel (or remake
%   the SBML file using SBMLFromExcel)
%
%   NOTE: This script requires that libSBML is installed.
%
%   NOTE: All IDs are assumed to be named C_, M_, E_, R_ for compartments,
%         metabolites, genes, and reactions. This is true for models
%         generated by SBMLFromExcel and those that follow the yeast
%         consensus network model formulation.
%
%   Usage: model=importModel(fileName,removeExcMets,isSBML2COBRA,supressWarnings)
%
%   Eduard Kerkhoven, 2018-02-08

if nargin<2
    removeExcMets=true;
end

if nargin<3
    isSBML2COBRA=false;
end

if nargin<4
    supressWarnings=false;
end

%This is to match the order of the fields to those you get from importing
%from Excel
model=[];
model.id=[];
model.description=[];
model.annotation=[];
model.rxns={};
model.mets={};
model.S=[];
model.lb=[];
model.ub=[];
model.rev=[];
model.c=[];
model.b=[];
model.comps={};
model.compNames={};
model.compOutside={};
model.compMiriams={};
model.rxnNames={};
model.rxnComps=[];
model.grRules={};
model.rxnGeneMat=[];
model.subSystems={};
model.eccodes={};
model.rxnMiriams={};
model.rxnNotes={};
model.rxnReferences={};
model.rxnConfidenceScores={};
model.genes={};
model.geneComps=[];
model.geneMiriams={};
model.geneShortNames={};
model.metNames={};
model.metComps=[];
model.inchis={};
model.metFormulas={};
model.metMiriams={};
model.metCharges=[];
model.unconstrained=[];

%Load the model using libSBML
modelSBML = TranslateSBML(fileName,0,0,[1 1]);

if isempty(modelSBML)
    EM='There is a problem with the SBML file. Try using the SBML Validator at http://sbml.org/Facilities/Validator';
    dispEM(EM);
end

% Remove the preceding strings for reactions, compartments and
% reactants/products in 'reaction' field. The strings for
% metabolites, genes and complexes are not removed, as we will need them
% later to identify them from 'species' field;
for i=1:numel(modelSBML.reaction)
    modelSBML.reaction(i).name=regexprep(modelSBML.reaction(i).name,'^R_','');
    modelSBML.reaction(i).id=regexprep(modelSBML.reaction(i).id,'^R_','');
    if isfield(modelSBML.reaction(i),'compartment')
        modelSBML.reaction(i).compartment=regexprep(modelSBML.reaction(i).compartment,'^C_','');
    end;
    for j=1:numel(modelSBML.reaction(i).reactant)
        modelSBML.reaction(i).reactant(j).species=regexprep(modelSBML.reaction(i).reactant(j).species,'^M_','');
    end;
    for j=1:numel(modelSBML.reaction(i).product)
        modelSBML.reaction(i).product(j).species=regexprep(modelSBML.reaction(i).product(j).species,'^M_','');
    end;
end;

%Retrieve compartment names and IDs
compartmentNames=cell(numel(modelSBML.compartment),1);
compartmentIDs=cell(numel(modelSBML.compartment),1);
compartmentOutside=cell(numel(modelSBML.compartment),1);
compartmentMiriams=cell(numel(modelSBML.compartment),1);

for i=1:numel(modelSBML.compartment)
    compartmentNames{i}=modelSBML.compartment(i).name;
    compartmentIDs{i}=regexprep(modelSBML.compartment(i).id,'^C_','');
    if isfield(modelSBML.compartment(i),'outside')
        if ~isempty(modelSBML.compartment(i).outside)
            compartmentOutside{i}=regexprep(modelSBML.compartment(i).outside,'^C_','');
        else
            compartmentOutside{i}='';
        end
    else
        compartmentOutside{i}=[];
    end

    if isfield(modelSBML.compartment(i),'annotation')
        compartmentMiriams{i}=parseMiriam(modelSBML.compartment(i).annotation);
    else
        compartmentMiriams{i}=[];
    end
end

%If there are no compartment names then use compartment id as name
if all(cellfun(@isempty,compartmentNames))
    compartmentNames=compartmentIDs;
end

%Retrieve info on metabolites, genes, complexes
metaboliteNames={};
metaboliteIDs={};
metaboliteCompartments={};
metaboliteUnconstrained=[];
metaboliteFormula={};
metaboliteInChI={};
metaboliteMiriams={};
metaboliteCharge=[];

geneNames={};
geneIDs={};
geneMiriams={};
geneShortNames={};
geneCompartments={};
complexIDs={};
complexNames={};

%If the file is not a COBRA Toolbox model. According to the format
%specified in the yeast consensus model both metabolites and genes are a
%type of 'species'. The metabolites have names starting with 'M_' and genes
%with 'E_'.

for i=1:numel(modelSBML.species)
    if ~isSBML2COBRA
        if length(modelSBML.species(i).id)>=2 && strcmpi(modelSBML.species(i).id(1:2),'E_')
            geneNames{numel(geneNames)+1,1}=modelSBML.species(i).name;

            %The "E_" is included in the ID. This is because it's only used
            %internally in this file and it makes the matching a little
            %smoother
            geneIDs{numel(geneIDs)+1,1}=modelSBML.species(i).id;
            geneCompartments{numel(geneCompartments)+1,1}=regexprep(modelSBML.species(i).compartment,'^C_','');
            
            %Get Miriam structure
            if isfield(modelSBML.species(i),'annotation')
                %Get Miriam info
                geneMiriam=parseMiriam(modelSBML.species(i).annotation);
                geneMiriams{numel(geneMiriams)+1,1}=geneMiriam;
            else
                geneMiriams{numel(geneMiriams)+1,1}=[];
            end

            %Protein short names (for example ERG10) are saved as SHORT
            %NAME: NAME in the notes-section of metabolites for SBML Level
            %2 and as PROTEIN_ASSOCIATION for each reaction in SBML Level 2
            % COBRA Toolbox format. For now only the SHORT NAME is loaded
            % and no mapping takes place
            if isfield(modelSBML.species(i),'notes')
                geneShortNames{numel(geneShortNames)+1,1}=parseNote(modelSBML.species(i).notes,'SHORT NAME');
            else
                geneShortNames{numel(geneShortNames)+1,1}='';
            end;
        %If it's a complex keep the ID and name
        elseif length(modelSBML.species(i).id)>=2 && strcmpi(modelSBML.species(i).id(1:3),'Cx_')
            complexIDs=[complexIDs;modelSBML.species(i).id];
            complexNames=[complexNames;modelSBML.species(i).name];
        else
            % If it is not gene or complex, then it must be a metabolite;
            metaboliteNames{numel(metaboliteNames)+1,1}=modelSBML.species(i).name;
            metaboliteIDs{numel(metaboliteIDs)+1,1}=regexprep(modelSBML.species(i).id,'^M_','');
            metaboliteCompartments{numel(metaboliteCompartments)+1,1}=regexprep(modelSBML.species(i).compartment,'^C_','');
            metaboliteUnconstrained(numel(metaboliteUnconstrained)+1,1)=modelSBML.species(i).boundaryCondition;

            %For each metabolite retrieve the formula and the InChI code if
            %available
            %First add the InChI code and the formula from the InChI. This
            %allows for overwriting the formula by setting the actual formula
            %field
            if ~isempty(modelSBML.species(i).annotation)
                %Get the formula if available
                startString='>InChI=';
                endString='</in:inchi>';
                formStart=strfind(modelSBML.species(i).annotation,startString);
                if isempty(formStart)
                    startString='InChI=';
                    endString='"/>';
                end;
                formStart=strfind(modelSBML.species(i).annotation,startString); 
                if ~isempty(formStart)
                    formEnd=strfind(modelSBML.species(i).annotation,endString);
                    formEndIndex=find(formEnd>formStart, 1 );
                    formula=modelSBML.species(i).annotation(formStart+numel(startString):formEnd(formEndIndex)-1);
                    metaboliteInChI{numel(metaboliteInChI)+1,1}=formula;

                    %The composition is most often present between the first
                    %and second "/" in the model. In some simple molecules,
                    %such as salts, there is no second "/". The formula is then
                    %assumed to be to the end of the string
                    compositionIndexes=strfind(formula,'/');
                    if numel(compositionIndexes)>1
                        metaboliteFormula{numel(metaboliteFormula)+1,1}=...
                            formula(compositionIndexes(1)+1:compositionIndexes(2)-1);
                    else
                        if numel(compositionIndexes)==1
                            %Probably a simple molecule which can have only one
                            %conformation
                            metaboliteFormula{numel(metaboliteFormula)+1,1}=...
                            formula(compositionIndexes(1)+1:numel(formula));
                        else
                            metaboliteFormula{numel(metaboliteFormula)+1,1}='';
                        end
                    end
				elseif isfield(modelSBML.species(i),'fbc_chemicalFormula')
                    metaboliteInChI{numel(metaboliteInChI)+1,1}='';
                    if ~isempty(modelSBML.species(i).fbc_chemicalFormula)
                        % Cannot extract InChi from formula, so remains empty.
                        metaboliteFormula{numel(metaboliteFormula)+1,1}=modelSBML.species(i).fbc_chemicalFormula;
                    else
                        metaboliteFormula{numel(metaboliteFormula)+1,1}='';
                    end;
                else
                    metaboliteInChI{numel(metaboliteInChI)+1,1}='';
                    metaboliteFormula{numel(metaboliteFormula)+1,1}='';
                end

                %Get Miriam info
                metMiriam=parseMiriam(modelSBML.species(i).annotation);
                metaboliteMiriams{numel(metaboliteMiriams)+1,1}=metMiriam;
            else
                metaboliteInChI{numel(metaboliteInChI)+1,1}='';
                if isfield(modelSBML.species(i),'notes')
                    metaboliteFormula{numel(metaboliteFormula)+1,1}=parseNote(modelSBML.species(i).notes,'FORMULA');
                else
                    metaboliteFormula{numel(metaboliteFormula)+1,1}='';
                end;
                metaboliteMiriams{numel(metaboliteMiriams)+1,1}=[];
            end
            if ~isempty(modelSBML.species(i).notes)
                if ~isfield(modelSBML.species(i),'annotation')
                    metaboliteFormula{numel(metaboliteFormula)+1,1}=parseNote(modelSBML.species(i).notes,'FORMULA');
                end;
            elseif ~isfield(modelSBML.species(i),'annotation')
            	metaboliteFormula{numel(metaboliteFormula)+1,1}='';
            end;
        end
        
    elseif isSBML2COBRA
        %The metabolite names are assumed to be M_NAME_COMPOSITION or
        %_NAME_COMPOSITION or NAME_COMPOSITION or NAME. Regular expressions
        %are used that only NAME_COMPOSITION or NAME would be possible
        
        modelSBML.species(i).name=regexprep(modelSBML.species(i).name,'^M_','');
        modelSBML.species(i).name=regexprep(modelSBML.species(i).name,'^_','');     
        underscoreIndex=strfind(modelSBML.species(i).name,'_');

        metaboliteNames{numel(metaboliteNames)+1,1}=modelSBML.species(i).name;
        
        metaboliteIDs{numel(metaboliteIDs)+1,1}=regexprep(modelSBML.species(i).id,'^M_','');
        metaboliteCompartments{numel(metaboliteCompartments)+1,1}=regexprep(modelSBML.species(i).compartment,'^C_','');

        %I think that COBRA doesn't set the boundary condition, but rather
        %uses name_b. Check for either
        metaboliteUnconstrained(numel(metaboliteUnconstrained)+1,1)=modelSBML.species(i).boundaryCondition;
        if strcmp(metaboliteIDs{end}(max(end-1,1):end),'_b')
            metaboliteUnconstrained(end)=1;
        end
        
        %Get the formula
        if max(underscoreIndex)<length(modelSBML.species(i).name)
            metaboliteFormula{numel(metaboliteFormula)+1,1}=modelSBML.species(i).name(max(underscoreIndex)+1:length(modelSBML.species(i).name));
        else
            metaboliteFormula{numel(metaboliteFormula)+1,1}='';
        end

        %The old COBRA version sometimes has composition information in
        %the notes instead
        if isfield(modelSBML.species(i),'notes')
            metaboliteFormula{numel(metaboliteFormula)+1,1}=parseNote(modelSBML.species(i).notes,'FORMULA');
        end;
    end
    % The following lines are executed regardless isSBML2COBRA setting;
    if isempty(modelSBML.species(i).id) || ~strcmpi(modelSBML.species(i).id(1:2),'E_')
        if isempty(modelSBML.species(i).id) || ~strcmpi(modelSBML.species(i).id(1:3),'Cx_')
            % Metabolite names could be of format NAME [compartment]. First
            % check whether metabolite name ends with square brackets, and
            % then check if the text within these brackets is a compartment
            % name. If so, then remove this section from the metabolite
            % name.
            comp.match=regexp(modelSBML.species(i).name,'.* \[(.*)\]$','match');
            if ~isempty(comp.match)
                comp.split=strsplit(comp.match{1},{'[',']'});
                comp.true=any(strcmpi({modelSBML.compartment.name},comp.split{2}));
                if comp.true==1
                    metaboliteNames{numel(metaboliteNames),1}=strtrim(comp.split{1});
                else
                    metaboliteNames{numel(metaboliteNames),1}=regexprep(modelSBML.species(i).name,'^M_','');
                end
            else
                %Use the full name
                metaboliteNames{i,1}=modelSBML.species(i).name;
            end
            if isfield(modelSBML.species(i),'fbc_charge')
                if ~isempty(modelSBML.species(i).fbc_charge) && modelSBML.species(i).isSetfbc_charge
                    metaboliteCharge(numel(metaboliteCharge)+1,1)=double(modelSBML.species(i).fbc_charge);
                else
                    if isfield(modelSBML.species(i),'notes')
                        if strfind(modelSBML.species(i).notes,'CHARGE')
                            metaboliteCharge(numel(metaboliteCharge)+1,1)=str2double(parseNote(modelSBML.species(i).notes,'CHARGE'));
                        else
                            metaboliteCharge(numel(metaboliteCharge)+1,1)=NaN;
                        end;
                    else
                        metaboliteCharge(numel(metaboliteCharge)+1,1)=NaN;
                    end
                end
            elseif isfield(modelSBML.species(i),'notes')
                if strfind(modelSBML.species(i).notes,'CHARGE')
                    metaboliteCharge(numel(metaboliteCharge)+1,1)=str2double(parseNote(modelSBML.species(i).notes,'CHARGE'));
                else
                    metaboliteCharge(numel(metaboliteCharge)+1,1)=NaN;
                end;
            else
                metaboliteCharge(numel(metaboliteCharge)+1,1)=NaN;
            end
            %Additional information from FBC format
            %Chemical formula
            if isfield(modelSBML.species(i),'fbc_chemicalFormula')
                if ~isempty(modelSBML.species(i).fbc_chemicalFormula)
                    metaboliteFormula{numel(metaboliteFormula),1}=modelSBML.species(i).fbc_chemicalFormula;
                end
            end
        end
    end
end

%Retrieve info on reactions
reactionNames=cell(numel(modelSBML.reaction),1);
reactionIDs=cell(numel(modelSBML.reaction),1);
subsystems=cell(numel(modelSBML.reaction),1);
subsystems(:,:)=cellstr('');
eccodes=cell(numel(modelSBML.reaction),1);
eccodes(:,:)=cellstr('');
confidencescores=cell(numel(modelSBML.reaction),1);
confidencescores(:,:)=cellstr('');
rxnreferences=cell(numel(modelSBML.reaction),1);
rxnreferences(:,:)=cellstr('');
rxnnotes=cell(numel(modelSBML.reaction),1);
rxnnotes(:,:)=cellstr('');
grRules=cell(numel(modelSBML.reaction),1);
grRules(:,:)=cellstr('');
grRulesFromModifier=grRules;
rxnComps=zeros(numel(modelSBML.reaction),1);
rxnMiriams=cell(numel(modelSBML.reaction),1);
reactionReversibility=zeros(numel(modelSBML.reaction),1);
reactionUB=zeros(numel(modelSBML.reaction),1);
reactionLB=zeros(numel(modelSBML.reaction),1);
reactionObjective=zeros(numel(modelSBML.reaction),1);

%Construct the stoichiometric matrix while the reaction info is read
S=zeros(numel(metaboliteIDs),numel(modelSBML.reaction));

counter=0;
%If FBC, then bounds have parameter ids defined for the whole model
if isfield(modelSBML,'parameter')
    parameter.name=cell(numel(modelSBML.parameter),1);
    parameter.name={modelSBML.parameter(:).id}';
    parameter.value={modelSBML.parameter(:).value}';
end

for i=1:numel(modelSBML.reaction)

    %Check that the reaction doesn't produce a complex and nothing else.
    %If so, then jump to the next reaction. This is because I get the
    %genes for complexes from the names and not from the reactions that
    %create them. This only applies to the non-COBRA format.
    if numel(modelSBML.reaction(i).product)==1
        if length(modelSBML.reaction(i).product(1).species)>=3
            if strcmp(modelSBML.reaction(i).product(1).species(1:3),'Cx_')==true
                continue;
            end
        end
    end

    %It didn't look like a gene complex-forming reaction
    counter=counter+1;

    reactionNames{counter}=modelSBML.reaction(i).name;

    reactionIDs{counter}=modelSBML.reaction(i).id;
    reactionReversibility(counter)=modelSBML.reaction(i).reversible;

    %If model is FBC, first get parameter of bound and then replace it
    %with the correct value. Probably faster with replace(), but this was
    %only introduced in Matlab R2016b
    if isfield(modelSBML.reaction(i),'fbc_lowerFluxBound')
        lb=modelSBML.reaction(i).fbc_lowerFluxBound;
        ub=modelSBML.reaction(i).fbc_upperFluxBound;
        for n=1:numel(parameter.value)
            lb=regexprep(lb,parameter.name(n),num2str(parameter.value{n}));
            ub=regexprep(ub,parameter.name(n),num2str(parameter.value{n}));
        end
        reactionLB(counter)=str2num(lb);
        reactionUB(counter)=str2num(ub);
    %The order of these parameters should not be hard coded
    elseif isfield(modelSBML.reaction(i).kineticLaw,'parameter')
        reactionLB(counter)=modelSBML.reaction(i).kineticLaw.parameter(1).value;
        reactionUB(counter)=modelSBML.reaction(i).kineticLaw.parameter(2).value;
        reactionObjective(counter)=modelSBML.reaction(i).kineticLaw.parameter(3).value;
    else
        if reactionReversibility(counter)==true
            reactionLB(counter)=-inf;
        else
            reactionLB(counter)=0;
        end
        reactionUB(counter)=inf;
        reactionObjective(counter)=0;
    end

    %Find the associated gene if available
    if isfield(modelSBML.reaction(i),'modifier')
        if ~isempty(modelSBML.reaction(i).modifier)
            rules='';
            for j=1:numel(modelSBML.reaction(i).modifier)
                modifier=modelSBML.reaction(i).modifier(j).species;
                if ~isempty(modifier)
                    if strcmpi(modifier(1:2),'E_')
                        index=find(strcmp(modifier,geneIDs));
                        %This should be unique and in the geneIDs list, otherwise
                        %something is wrong
                        if numel(index)~=1
                            EM=['Could not get the gene association data from reaction ' reactionIDs{i}];
                            dispEM(EM);
                        end
                        %Add the association
                        %rxnGeneMat(i,index)=1;
                        if ~isempty(rules)
                            rules=[rules ' or (' geneNames{index} ')'];
                        else
                            rules=['(' geneNames{index} ')'];
                        end
                    elseif strcmp(modifier(1:2),'s_')
                        index=find(strcmp(modifier,metaboliteIDs));
                        %This should be unique and in the geneIDs list, otherwise
                        %something is wrong
                        if numel(index)~=1
                            EM=['Could not get the gene association data from reaction ' reactionIDs{i}];
                            dispEM(EM);
                        end
                        %Add the association
                        %rxnGeneMat(i,index)=1;
                        if ~isempty(rules)
                            rules=[rules ' or (' metaboliteIDs{index} ')'];
                        else
                            rules=['(' metaboliteIDs{index} ')'];
                        end
                    else
                       %It seems to be a complex. Add the corresponding
                       %genes from the name of the complex (not the
                       %reaction that creates it)
                       index=find(strcmp(modifier,complexIDs));
                       if numel(index)==1
                           if ~isempty(rules)
                                rules=[rules ' or (' strrep(complexNames{index},':',' and ') ')'];
                            else
                                rules=['(' strrep(complexNames{index},':',' and ') ')'];
                           end
                       else
                          %Could not find a complex
                          EM=['Could not get the gene association data from reaction ' reactionIDs{i}];
                          dispEM(EM);
                       end
                    end
                end
            end
            grRules{counter}=rules;
            grRulesFromModifier{counter}=rules;%Backup copy for grRules, useful to parse Yeast 7.6
        end
    end
    % This section was previously executed only if isSBML2COBRA is true.
    % Now it will be executed, if 'GENE_ASSOCIATION' is found in
    % modelSBML.reaction(i).notes
    if isfield(modelSBML.reaction(i),'notes')
        if strfind(modelSBML.reaction(i).notes,'GENE_ASSOCIATION')
            geneAssociation=parseNote(modelSBML.reaction(i).notes,'GENE_ASSOCIATION');
        elseif strfind(modelSBML.reaction(i).notes,'GENE ASSOCIATION')
            geneAssociation=parseNote(modelSBML.reaction(i).notes,'GENE ASSOCIATION');
        else
            geneAssociation='';
        end;
    end;

    if ~isempty(geneAssociation)
    	%This adds the grRules. The gene list and rxnGeneMat
    	%are created later
    	grRules{counter}=geneAssociation;
    end;
    
    % If FBC, get gene association data from corresponding fields;
    if isfield(modelSBML.reaction(i),'fbc_geneProductAssociation')
        if ~isempty(modelSBML.reaction(i).fbc_geneProductAssociation) && ~isempty(modelSBML.reaction(i).fbc_geneProductAssociation.fbc_association)
            grRules{counter}=modelSBML.reaction(i).fbc_geneProductAssociation.fbc_association.fbc_association;
        end;
    end;

    %Add reaction compartment
    if isfield(modelSBML.reaction(i),'compartment')
        if ~isempty(modelSBML.reaction(i).compartment)
            rxnComp=modelSBML.reaction(i).compartment;
        else
            rxnComp='';
        end;
    elseif isfield(modelSBML.reaction(i),'notes')
        rxnComp=parseNote(modelSBML.reaction(i).notes,'COMPARTMENT');
    end;
    if ~isempty(rxnComp)
        %Find it in the compartment list
        [~, J]=ismember(rxnComp,compartmentIDs);
        rxnComps(counter)=J;
    end;

    %Get other Miriam fields. This may include for example database indexes
    %to organism-specific databases. EC-codes are supported by the COBRA
    %Toolbox format and are therefore loaded separately
    if isSBML2COBRA==false
        miriamStruct=parseMiriam(modelSBML.reaction(i).annotation);
        rxnMiriams{counter}=miriamStruct;
        if isfield(modelSBML.reaction(i),'notes')
            subsystems{counter,1}=parseNote(modelSBML.reaction(i).notes,'SUBSYSTEM');
            confidencescores{counter,1}=parseNote(modelSBML.reaction(i).notes,'Confidence Level');
            rxnreferences{counter,1}=parseNote(modelSBML.reaction(i).notes,'AUTHORS');
            rxnnotes{counter,1}=parseNote(modelSBML.reaction(i).notes,'NOTES');
        end;
    end

    %Get ec-codes
    eccode='';
    if ~isempty(modelSBML.reaction(i).annotation)
        if strfind(modelSBML.reaction(i).annotation,'urn:miriam:ec-code')
        	eccode=parseAnnotation(modelSBML.reaction(i).annotation,'urn:miriam:',':','ec-code');
        elseif strfind(modelSBML.reaction(i).annotation,'http://identifiers.org/ec-code')
        	eccode=parseAnnotation(modelSBML.reaction(i).annotation,'http://identifiers.org/','/','ec-code');
        end;
    elseif isfield(modelSBML.reaction(i),'notes')
        if strfind(modelSBML.reaction(i).notes,'EC Number')
            eccode=[eccode parseNote(modelSBML.reaction(i).notes,'EC Number')];
        elseif strfind(modelSBML.reaction(i).notes,'PROTEIN_CLASS')
            eccode=[eccode parseNote(modelSBML.reaction(i).notes,'PROTEIN_CLASS')];
        end;  
    end;
	eccodes{counter}=eccode;
    
    %Add all reactants
    for j=1:numel(modelSBML.reaction(i).reactant)
       %Get the index of the metabolite in metaboliteIDs. External
       %metabolites will be removed at a later stage
       metIndex=find(strcmp(modelSBML.reaction(i).reactant(j).species,metaboliteIDs),1);
       if isempty(metIndex)
           EM=['Could not find metabolite ' modelSBML.reaction(i).reactant(j).species ' in reaction ' reactionIDs{counter}];
           dispEM(EM);
       end
       S(metIndex,counter)=S(metIndex,counter)+modelSBML.reaction(i).reactant(j).stoichiometry*-1;
    end

    %Add all products
    for j=1:numel(modelSBML.reaction(i).product)
       %Get the index of the metabolite in metaboliteIDs.
       metIndex=find(strcmp(modelSBML.reaction(i).product(j).species,metaboliteIDs),1);
       if isempty(metIndex)
           EM=['Could not find metabolite ' modelSBML.reaction(i).reactant(j).species ' in reaction ' reactionIDs{counter}];
           dispEM(EM);
       end
       S(metIndex,counter)=S(metIndex,counter)+modelSBML.reaction(i).product(j).stoichiometry;
    end
end

%subSystems can be stored as groups instead of in annotations
if isfield(modelSBML,'groups_group')
    for i=1:numel(modelSBML.groups_group)
        [~, idx] = ismember({modelSBML.groups_group(i).groups_member(:).groups_idRef}, reactionIDs);
        for j=1:numel(idx)
            if isempty(subsystems{idx(j)}) % First subsystem printed as string
                subsystems{idx(j)} = modelSBML.groups_group(i).groups_name;
            elseif ischar(subsystems{idx(j)}) % Second subsystem, convert to cell array
                subsystems{idx(j)} = {subsystems{idx(j)}, modelSBML.groups_group(i).groups_name};
            else % Third and consecutive subsystems: concatenate
                subsystems{idx(j)} = horzcat(subsystems{idx(j)}, modelSBML.groups_group(i).groups_name);
            end
        end
    end
end

%Shrink the structures if complex-forming reactions had to be skipped
reactionNames=reactionNames(1:counter);
reactionIDs=reactionIDs(1:counter);
subsystems=subsystems(1:counter);
eccodes=eccodes(1:counter);
confidencescores=confidencescores(1:counter);
rxnreferences=rxnreferences(1:counter);
rxnnotes=rxnnotes(1:counter);
grRules=grRules(1:counter);
rxnMiriams=rxnMiriams(1:counter);
reactionReversibility=reactionReversibility(1:counter);
reactionUB=reactionUB(1:counter);
reactionLB=reactionLB(1:counter);
reactionObjective=reactionObjective(1:counter);
S=S(:,1:counter);

model.description=modelSBML.name;
model.id=modelSBML.id;
model.rxns=reactionIDs;
model.mets=metaboliteIDs;
model.S=sparse(S);
model.lb=reactionLB;
model.ub=reactionUB;
model.rev=reactionReversibility;
model.c=reactionObjective;
model.b=zeros(numel(metaboliteIDs),1);
model.comps=compartmentIDs;
model.compNames=compartmentNames;
model.rxnConfidenceScores=confidencescores;
model.rxnReferences=rxnreferences;
model.rxnNotes=rxnnotes;

%Load annotation if available. If there are several authors, only the first
%author credentials are imported
if isfield(modelSBML,'annotation')
    endString='</';
    I=strfind(modelSBML.annotation,endString);
    J=strfind(modelSBML.annotation,'<vCard:Family>');
    if any(J)
       model.annotation.familyName=modelSBML.annotation(J(1)+14:I(find(I>J(1),1))-1);
    end
    J=strfind(modelSBML.annotation,'<vCard:Given>');
    if any(J)
       model.annotation.givenName=modelSBML.annotation(J(1)+13:I(find(I>J(1),1))-1);
    end
    J=strfind(modelSBML.annotation,'<vCard:EMAIL>');
    if any(J)
       model.annotation.email=modelSBML.annotation(J(1)+13:I(find(I>J(1),1))-1);
    end
    J=strfind(modelSBML.annotation,'<vCard:Orgname>');
    if any(J)
       model.annotation.organization=modelSBML.annotation(J(1)+15:I(find(I>J(1),1))-1);
    end
    endString='"/>';
    I=strfind(modelSBML.annotation,endString);
    if strfind(modelSBML.annotation,'"urn:miriam:')
        J=strfind(modelSBML.annotation,'"urn:miriam:');
        if any(J)
            model.annotation.taxonomy=modelSBML.annotation(J+12:I(find(I>J,1))-1);
        end;
    else
    	J=strfind(modelSBML.annotation,'"http://identifiers.org/');
        if any(J)
            model.annotation.taxonomy=modelSBML.annotation(J+24:I(find(I>J,1))-1);
        end
    end
end
if isfield(modelSBML,'notes')
    startString=strfind(modelSBML.notes,'xhtml">');
    endString=strfind(modelSBML.notes,'</body>');
    if any(startString) && any(endString)
       model.annotation.note=modelSBML.notes(startString+7:endString-1);
       model.annotation.note=regexprep(model.annotation.note,'<p>|</p>','');
       model.annotation.note=strtrim(model.annotation.note);
    end
end

if any(~cellfun(@isempty,compartmentOutside))
    model.compOutside=compartmentOutside;
end

model.rxnNames=reactionNames;
model.metNames=metaboliteNames;

%Match the compartments for metabolites
[~, J]=ismember(metaboliteCompartments,model.comps);
model.metComps=J;

%If any genes have been loaded (only for the new format)
if ~isempty(geneNames)
    %In some rare cases geneNames may not necessarily be used in grRules.
    %That is true for Yeast 7.6. It's therefore important to change gene
    %systematic names to geneIDs in sophisticated way. Gene systematic
    %names are not unique, since exactly the same name may be in different
    %compartments
    if all(cellfun(@isempty,strfind(grRules,geneNames{1})))
        geneShortNames=geneNames;
        % geneShortNames contain compartments as well, so these are
        % removed;
        geneShortNames=regexprep(geneShortNames,' \[.+$','');
        % grRules obtained from modifier fields contain geneNames. These
        % are changed into geneIDs. grRulesFromModifier is a good way to
        % have geneIDs and rxns association when it's important to resolve
        % systematic name ambiguities;
        grRulesFromModifier=regexprep(regexprep(grRulesFromModifier,'\[|\]','_'),regexprep(geneNames,'\[|\]','_'),geneIDs);
        grRules=regexprep(regexprep(grRules,'\[|\]','_'),regexprep(geneNames,'\[|\]','_'),geneIDs);
        
        %Yeast 7.6 contains several metabolites, which were used in gene
        %associations. For that reason, the list of species ID is created
        %and we then check whether any of them have kegg.genes annotation
        %thereby obtaining systematic gene names;
        geneShortNames=vertcat(geneShortNames,metaboliteNames);
        geneIDs=vertcat(geneIDs,metaboliteIDs);
        geneSystNames=extractMiriam(vertcat(geneMiriams,metaboliteMiriams),'kegg.genes');
        geneSystNames=regexprep(geneSystNames,'^.+:','');
        geneCompartments=vertcat(geneCompartments,metaboliteCompartments);
        geneMiriams=vertcat(geneMiriams,metaboliteMiriams);
        
        %Now we retain information for only these entries, which have
        %kegg.genes annotation;
        geneShortNames=geneShortNames(~cellfun('isempty',geneSystNames));        
        geneIDs=geneIDs(~cellfun('isempty',geneSystNames));
        geneSystNames=geneSystNames(~cellfun('isempty',geneSystNames));
        geneCompartments=geneCompartments(~cellfun('isempty',geneSystNames));
        geneMiriams=geneMiriams(~cellfun('isempty',geneSystNames));
        %Now we reorder geneIDs and geneSystNames by geneSystNames string
        %length;
        geneNames=geneIDs;%Backuping geneIDs, since we need unsorted order for later;
        [~, Indx] = sort(cellfun('size', geneSystNames, 2), 'descend');
        geneIDs = geneIDs(Indx);
        geneSystNames = geneSystNames(Indx);
        for i=1:numel(geneSystNames)
            for j=1:numel(grRules)
                if strfind(grRules{j},geneSystNames{i})
                    if ~isempty(grRules{j})
                        if sum(ismember(geneSystNames,geneSystNames{i}))==1
                            grRules{j}=regexprep(grRules{j},geneSystNames{i},geneIDs{i});
                        elseif sum(ismember(geneSystNames,geneSystNames{i}))>1
                            counter=0;
                            ovrlpIDs=geneIDs(ismember(geneSystNames,geneSystNames{i}));
                            for k=1:numel(ovrlpIDs)
                                if strfind(grRulesFromModifier{j},ovrlpIDs{k})
                                    counter=counter+1;
                                    grRules{j}=regexprep(grRules{j},geneSystNames{i},ovrlpIDs{k});
                                end;
                                if counter>1
                                    EM=['Gene association is ambiguous for reaction ' modelSBML.reaction(j).id];
                                    dispEM(EM);
                                end;
                            end;
                        end;
                    end;
                end;
            end;
        end;
    end;              
    model.genes=geneNames;
    model.rxnGeneMat=getGeneMat(grRules,geneNames);
    model.grRules=grRules;
    %Match the compartments for genes
    [~, J]=ismember(geneCompartments,model.comps);
    model.geneComps=J;
else
    if ~isempty(grRules)
       %In the non-COBRA version genes are surrounded by parenthesis even
       %if they are the only gene. Also, only single spaces are used
       %between genes. I'm pretty sure this is compatible with COBRA Toolbox so I
       %change it to be the same here.
       grRules=strrep(grRules,'  ',' ');
       grRules=strrep(grRules,'( ','(');
       grRules=strrep(grRules,' )',')');
       grRules=strrep(grRules,') or (','*%%%%*');
       grRules=strrep(grRules,' or ',') or (');
       grRules=strrep(grRules,'*%%%%*',') or (');
       grRules=regexprep(grRules,'\(\((.*)\)\)','\($1\)'); 

       %Not very neat, but add parenthesis if missing
       for i=1:numel(grRules)
          if any(grRules{i})
              if ~strcmp(grRules{i}(1),'(')
                  grRules{i}=['(' grRules{i} ')'];
              end
          end
       end
       %If fbc_geneProduct exist, follow the specified gene order, such
       %that matching geneShortNames in function below will work.
       if isfield(modelSBML,'fbc_geneProduct')
           [rxnGeneMat, genes]=getGeneMat(grRules,{modelSBML.fbc_geneProduct.fbc_id});
       else
           [rxnGeneMat, genes]=getGeneMat(grRules);
       end
       model.rxnGeneMat=rxnGeneMat;
       model.genes=genes;
       model.grRules=grRules;
    end
end

% Make sure that AND and OR string are in lowercase in grRules
model.grRules=strrep(model.grRules,' AND ',' and ');
model.grRules=strrep(model.grRules,' OR ',' or ');

if all(cellfun(@isempty,geneShortNames))
    if isfield(modelSBML,'fbc_geneProduct')
        for i=1:numel(genes)
            if ~isempty(modelSBML.fbc_geneProduct(i).fbc_label)
                geneShortNames{i,1}=modelSBML.fbc_geneProduct(i).fbc_label;
            elseif ~isempty(modelSBML.fbc_geneProduct(i).fbc_name)
                geneShortNames{i,1}=modelSBML.fbc_geneProduct(i).fbc_name;
            else
                geneShortNames{i,1}='';
            end;
        end;
    end;
end;

%If any InChIs have been loaded
if any(~cellfun(@isempty,metaboliteInChI))
    model.inchis=metaboliteInChI;
end

%If any formulas have been loaded
if any(~cellfun(@isempty,metaboliteFormula))
    model.metFormulas=metaboliteFormula;
end

%If any charges have been loaded
if ~isempty(metaboliteCharge)
    model.metCharges=metaboliteCharge;
end

%If any gene short names have been loaded
if any(~cellfun(@isempty,geneShortNames))
    model.geneShortNames=geneShortNames;
end

%If any Miriam strings for compartments have been loaded
if any(~cellfun(@isempty,compartmentMiriams))
    model.compMiriams=compartmentMiriams;
end

%If any Miriam strings for metabolites have been loaded
if any(~cellfun(@isempty,metaboliteMiriams))
    model.metMiriams=metaboliteMiriams;
end

%If any subsystems have been loaded
if any(~cellfun(@isempty,subsystems))
    model.subSystems=subsystems;
end
if any(rxnComps)
   if all(rxnComps)
       model.rxnComps=rxnComps;
   else
       if supressWarnings==false
           EM='The compartments for the following reactions could not be matched. Ignoring reaction compartment information';
           dispEM(EM,false,model.rxns(rxnComps==0));
       end
   end
end

%If any ec-codes have been loaded
if any(~cellfun(@isempty,eccodes))
    model.eccodes=eccodes;
end

%If any Miriam strings for reactions have been loaded
if any(~cellfun(@isempty,rxnMiriams))
    model.rxnMiriams=rxnMiriams;
end

%If any Miriam strings for genes have been loaded
if any(~cellfun(@isempty,geneMiriams))
    model.geneMiriams=geneMiriams;
end

model.unconstrained=metaboliteUnconstrained;

% Convert SBML IDs back into their original strings. Here we are using part
% from convertSBMLID, originating from the COBRA Toolbox
model.rxns=regexprep(model.rxns,'__([0-9]+)__','${char(str2num($1))}');
model.mets=regexprep(model.mets,'__([0-9]+)__','${char(str2num($1))}');
model.comps=regexprep(model.comps,'__([0-9]+)__','${char(str2num($1))}');
model.grRules=regexprep(model.grRules,'__([0-9]+)__','${char(str2num($1))}');
model.genes=regexprep(model.genes,'__([0-9]+)__','${char(str2num($1))}');

%Remove unused fields
if isempty(model.annotation)
    model=rmfield(model,'annotation');
end
if isempty(model.compOutside)
    model=rmfield(model,'compOutside');
end
if isempty(model.compMiriams)
    model=rmfield(model,'compMiriams');
end
if isempty(model.rxnComps)
    model=rmfield(model,'rxnComps');
end
if isempty(model.grRules)
    model=rmfield(model,'grRules');
end
if isempty(model.rxnGeneMat)
    model=rmfield(model,'rxnGeneMat');
end
if isempty(model.subSystems)
    model=rmfield(model,'subSystems');
end
if isempty(model.eccodes)
    model=rmfield(model,'eccodes');
end
if isempty(model.rxnMiriams)
    model=rmfield(model,'rxnMiriams');
end
if cellfun(@isempty,model.rxnNotes)
	model=rmfield(model,'rxnNotes');
end
if cellfun(@isempty,model.rxnReferences)
	model=rmfield(model,'rxnReferences');
end
if cellfun(@isempty,model.rxnConfidenceScores)
	model=rmfield(model,'rxnConfidenceScores');
end
if isempty(model.genes)
    model=rmfield(model,'genes');
elseif isrow(model.genes)
    model.genes=transpose(model.genes);
end
if isempty(model.geneComps)
    model=rmfield(model,'geneComps');
end
if isempty(model.geneMiriams)
    model=rmfield(model,'geneMiriams');
end
if isempty(model.geneShortNames)
    model=rmfield(model,'geneShortNames');
end
if isempty(model.inchis)
    model=rmfield(model,'inchis');
end
if isempty(model.metFormulas)
    model=rmfield(model,'metFormulas');
end
if isempty(model.metMiriams)
    model=rmfield(model,'metMiriams');
end
if ~any(model.metCharges)
    model=rmfield(model,'metCharges');
end

%This just removes the grRules if no genes have been loaded
if ~isfield(model,'genes') && isfield(model,'grRules')
   model=rmfield(model,'grRules');
end

%The metabolite ids may still contain the compartment abbreviations in the
%end, so these are removed. However, such removal is only saved if the
%metabolite ids are still unique;
for i=1:numel(model.comps)
    tempMets=model.mets;
    tempMets=regexprep(tempMets,'\]$','');
    tempMets=regexprep(tempMets,['\[', model.comps{i}, '$'],'');
    if numel(unique(tempMets))==numel(model.mets)
        model.mets=tempMets;
    end;
end;

%Print warnings about bad structure
if supressWarnings==false
    checkModelStruct(model,false);
end

if removeExcMets==true
    model=simplifyModel(model);
end
end

function [rxnGeneMat, matchGenes]=getGeneMat(grRules,matchGenes)
%Constructs the rxnGeneMat matrix and the cell array with gene names from
%the grRules. Uses the genes in the order defined by matchGenes if supplied. No
%checks are made here since that should have been made before.

if nargin<2
    matchGenes={};
end

%Assume that everything that isn't a paranthesis, " AND " or " or " is a
%gene name
genes=strrep(grRules,'(','');
genes=strrep(genes,')','');
genes=strrep(genes,' or ',' ');
genes=strrep(genes,' and ',' ');
genes=strrep(genes,' OR ',' ');
genes=strrep(genes,' AND ',' ');
genes=regexp(genes,' ','split');

if isempty(matchGenes)
    allNames={};
    for i=1:numel(genes)
        allNames=[allNames genes{i}];
    end
    matchGenes=unique(allNames)';

    %Remove the empty element if present
    if isempty(matchGenes{1})
        matchGenes(1)=[];
    end
end

%Create the matrix
rxnGeneMat=zeros(numel(genes),numel(matchGenes));

for i=1:numel(genes)
    if ~isempty(genes{i})
        for j=1:numel(genes{i})
            if ~isempty(genes{i}{j})
                index=find(strcmp(genes{i}{j},matchGenes));
                if numel(index)==1
                    rxnGeneMat(i,index)=1;
                else
                    EM=['The gene ' genes{i}{j} ' could not be matched to a gene in the gene list'];
                    dispEM(EM);
                end
            end
        end
    end
end
rxnGeneMat=sparse(rxnGeneMat);
end

function fieldContent=parseNote(searchString,fieldName)
% The function obtains the particular information from 'notes' field, using
% fieldName as the dummy string
    
fieldContent='';

if strfind(searchString,fieldName)
    [~,targetString] = regexp(searchString,['<p>' fieldName '.*?</p>'],'tokens','match');
    targetString=regexprep(targetString,'<p>|</p>','');
    targetString=regexprep(targetString,[fieldName, ':'],'');    
    for i=1:numel(targetString)
        fieldContent=[fieldContent ';' strtrim(targetString{1,i})];
    end;
    fieldContent=regexprep(fieldContent,'^;|;$','');
else
    fieldContent='';
end
end

function fieldContent=parseAnnotation(searchString,startString,midString,fieldName)

fieldContent='';

% Removing whitespace characters from the ending strings, which may occur
% in several cases;
searchString=regexprep(searchString,'" />','"/>');
[~,targetString] = regexp(searchString,['<rdf:li rdf:resource="' startString fieldName midString '.*?"/>'],'tokens','match');
targetString=regexprep(targetString,'<rdf:li rdf:resource="|"/>','');
targetString=regexprep(targetString,startString,'');
targetString=regexprep(targetString,[fieldName midString],'');

for i=1:numel(targetString)
	fieldContent=[fieldContent ';' strtrim(targetString{1,i})];
end;
       
fieldContent=regexprep(fieldContent,'^;|;$','');
end

function miriamStruct=parseMiriam(searchString)
%Generates miriam structure from annotation field;

%Finding whether miriams are written in the old or the new way;
if strfind(searchString,'urn:miriam:')
    startString='urn:miriam:';
    midString=':';
elseif strfind(searchString,'http://identifiers.org/')
    startString='http://identifiers.org/';
    midString='/';
else
    miriamStruct=[];
    return;
end;

miriamStruct=[];

searchString=regexprep(searchString,'" />','"/>');
[~,targetString] = regexp(searchString,'<rdf:li rdf:resource=".*?"/>','tokens','match');
targetString=regexprep(targetString,'<rdf:li rdf:resource="|"/>','');
targetString=regexprep(targetString,startString,'');
targetString=regexprep(targetString,midString,'/','once');

counter=0;
for i=1:numel(targetString)
    if ~regexp(targetString{1,i},'inchi')
        if ~regexp(targetString{1,i},'ec-code')
            counter=counter+1;
            miriamStruct.name{counter,1} = regexprep(targetString{1,i},'/.+','','once');   
            miriamStruct.value{counter,1} = regexprep(targetString{1,i},[miriamStruct.name{counter,1} midString],'','once');
        end;
    end;
end;
end
